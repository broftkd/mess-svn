//============================================================
//
//  input.c - SDL implementation of MAME input routines
//
//  Copyright (c) 1996-2007, Nicola Salmoria and the MAME Team.
//  Visit http://mamedev.org for licensing and usage restrictions.
//
//  SDLMAME by Olivier Galibert and R. Belmont
//
//============================================================

// standard sdl header
#include <SDL/SDL.h>
#include <SDL/SDL_thread.h>
#include <ctype.h>

// MAME headers
#include "osdepend.h"
#include "driver.h"
#include "window.h"
#include "options.h"
#include "input.h"
#include "ui.h"

#include "osdsdl.h"

#ifdef MESS
#include "inputx.h"
#include "uimess.h"
#endif

//============================================================
//  PARAMETERS
//============================================================

#define MAX_KEYBOARDS		1
#define MAX_MICE			8
#define MAX_JOYSTICKS		8
#define MAX_LIGHTGUNS		2

#define MAX_KEYS			256

#define MAX_JOY				256
#define MAX_AXES			8
#define MAX_BUTTONS			32
#define MAX_POV				4

#define MAX_JOYMAP 		(MAX_JOYSTICKS*2)

enum
{
	ANALOG_TYPE_PADDLE = 0,
	ANALOG_TYPE_ADSTICK,
	ANALOG_TYPE_LIGHTGUN,
	ANALOG_TYPE_PEDAL,
	ANALOG_TYPE_DIAL,
	ANALOG_TYPE_TRACKBALL,
	ANALOG_TYPE_POSITIONAL,
#ifdef MESS
	ANALOG_TYPE_MOUSE,
#endif // MESS
	ANALOG_TYPE_COUNT
};

enum
{
	SELECT_TYPE_KEYBOARD = 0,
	SELECT_TYPE_MOUSE,
	SELECT_TYPE_JOYSTICK,
	SELECT_TYPE_LIGHTGUN
};



//============================================================
//  MACROS
//============================================================

#define ELEMENTS(x)			(sizeof(x) / sizeof((x)[0]))



//============================================================
//  GLOBAL VARIABLES
//============================================================




//============================================================
//  LOCAL VARIABLES
//============================================================

// this will be filled in dynamically
static os_code_info	codelist[MAX_KEYS+MAX_JOY];
static int					total_codes;

#ifdef SDLMAME_WIN32

// input lock
static osd_lock				*input_lock;

// input buffer
#define MAX_BUF_EVENTS 		(100)
static SDL_Event			event_buf[MAX_BUF_EVENTS];
static int					event_buf_count;

#endif

// global states
static int					input_paused;
static int					use_mouse;

// Controller override options
static float				a2d_deadzone;
static int					use_joystick;
static int					steadykey;
static UINT8				analog_type[ANALOG_TYPE_COUNT];

// keyboard states
static INT8					keyboard_state[0x3ff];

// additional key data
static INT8					oldkey[MAX_KEYS];
static INT8					currkey[MAX_KEYS];

// mouse states
static int					mouse_active;
static struct {
	int lX, lY;
	int buttons[MAX_BUTTONS];
} mouse_state[MAX_JOYSTICKS];

// joystick states
static int					joystick_count;
static UINT8					joystick_digital[MAX_JOYSTICKS][MAX_AXES];
//static char					joystick_name[MAX_JOYSTICKS][1024];
static SDL_Joystick			*joystick_device[MAX_JOYSTICKS];
static struct {
	int axes[MAX_AXES];
	int buttons[MAX_BUTTONS];
} joystick_state[MAX_JOYSTICKS];

// gun states
//static INT32					gun_axis[MAX_LIGHTGUNS][2];


//============================================================
//  PROTOTYPES
//============================================================

static void extract_input_config(void);
static void updatekeyboard(void);
static void init_keycodes(void);
static void init_joymap(void);
static void add_joylist_entry(const char *name, os_code code, input_code standardcode);


//============================================================
//  KEYBOARD/JOYSTICK LIST
//============================================================

// macros for building/mapping keyboard codes
#define KEYCODE(sdlk, vk, ascii)    		((sdlk) | ((vk) << 10) | ((ascii) << 18))
#define SDLCODE(keycode)     			((keycode) & 0x3ff)
#define VKCODE(keycode)				(((keycode) >> 10) & 0xff)
#define ASCIICODE(keycode)			(((keycode) >> 18) & 0xff)

// macros for building/mapping joystick codes
#define JOYCODE(joy, type, index)	((index) | ((type) << 8) | ((joy) << 12) | 0x80000000)
#define JOYINDEX(joycode)			((joycode) & 0xff)
#define CODETYPE(joycode)			(((joycode) >> 8) & 0xf)
#define JOYNUM(joycode)				(((joycode) >> 12) & 0xf)

// macros for differentiating the two
#define IS_KEYBOARD_CODE(code)		(((code) & 0x80000000) == 0)
#define IS_JOYSTICK_CODE(code)		(((code) & 0x80000000) != 0)

// joystick types
enum
{
	CODETYPE_KEYBOARD = 0,
	CODETYPE_AXIS_NEG,
	CODETYPE_AXIS_POS,
	CODETYPE_POV_UP,
	CODETYPE_POV_DOWN,
	CODETYPE_POV_LEFT,
	CODETYPE_POV_RIGHT,
	CODETYPE_BUTTON,
	CODETYPE_JOYAXIS,
	CODETYPE_JOYAXIS_NEG,
	CODETYPE_JOYAXIS_POS,
	CODETYPE_MOUSEAXIS,
	CODETYPE_MOUSE_NEG,
	CODETYPE_MOUSE_POS,
	CODETYPE_MOUSEBUTTON,
	CODETYPE_GUNAXIS
};

// master keyboard translation table
const int def_key_trans_table[][4] =
{
	// MAME key			SDL key			vkey	ascii
	{ KEYCODE_ESC, 			SDLK_ESCAPE,	     	27,	27 },
	{ KEYCODE_1, 			SDLK_1,		     	'1',	'1' },
	{ KEYCODE_2, 			SDLK_2,		     	'2',	'2' },
	{ KEYCODE_3, 			SDLK_3,		     	'3',	'3' },
	{ KEYCODE_4, 			SDLK_4,		     	'4',	'4' },
	{ KEYCODE_5, 			SDLK_5,		     	'5',	'5' },
	{ KEYCODE_6, 			SDLK_6,		     	'6',	'6' },
	{ KEYCODE_7, 			SDLK_7,		     	'7',	'7' },
	{ KEYCODE_8, 			SDLK_8,		     	'8',	'8' },
	{ KEYCODE_9, 			SDLK_9,		     	'9',	'9' },
	{ KEYCODE_0, 			SDLK_0,		     	'0',	'0' },
	{ KEYCODE_MINUS, 		SDLK_MINUS, 	     	0xbd,	'-' },
	{ KEYCODE_EQUALS, 		SDLK_EQUALS,	      	0xbb,	'=' },
	{ KEYCODE_BACKSPACE,		SDLK_BACKSPACE,         8, 	8 },
	{ KEYCODE_TAB, 			SDLK_TAB, 	     	9, 	9 },
	{ KEYCODE_Q, 			SDLK_q,		     	'Q',	'Q' },
	{ KEYCODE_W, 			SDLK_w,		     	'W',	'W' },
	{ KEYCODE_E, 			SDLK_e,		     	'E',	'E' },
	{ KEYCODE_R, 			SDLK_r,		     	'R',	'R' },
	{ KEYCODE_T, 			SDLK_t,		     	'T',	'T' },
	{ KEYCODE_Y, 			SDLK_y,		     	'Y',	'Y' },
	{ KEYCODE_U, 			SDLK_u,		     	'U',	'U' },
	{ KEYCODE_I, 			SDLK_i,		     	'I',	'I' },
	{ KEYCODE_O, 			SDLK_o,		     	'O',	'O' },
	{ KEYCODE_P, 			SDLK_p,		     	'P',	'P' },
	{ KEYCODE_OPENBRACE,		SDLK_LEFTBRACKET, 	0xdb,	'[' },
	{ KEYCODE_CLOSEBRACE,		SDLK_RIGHTBRACKET, 	0xdd,	']' },
	{ KEYCODE_ENTER, 		SDLK_RETURN, 		13, 	13 },
	{ KEYCODE_LCONTROL, 		SDLK_LCTRL, 	        0, 	0 },
	{ KEYCODE_A, 			SDLK_a,		     	'A',	'A' },
	{ KEYCODE_S, 			SDLK_s,		     	'S',	'S' },
	{ KEYCODE_D, 			SDLK_d,		     	'D',	'D' },
	{ KEYCODE_F, 			SDLK_f,		     	'F',	'F' },
	{ KEYCODE_G, 			SDLK_g,		     	'G',	'G' },
	{ KEYCODE_H, 			SDLK_h,		     	'H',	'H' },
	{ KEYCODE_J, 			SDLK_j,		     	'J',	'J' },
	{ KEYCODE_K, 			SDLK_k,		     	'K',	'K' },
	{ KEYCODE_L, 			SDLK_l,		     	'L',	'L' },
	{ KEYCODE_COLON, 		SDLK_SEMICOLON,		0xba,	';' },
	{ KEYCODE_QUOTE, 		SDLK_QUOTE,		0xde,	'\'' },
	{ KEYCODE_TILDE, 		SDLK_BACKQUOTE,      	0xc0,	'`' },
	{ KEYCODE_LSHIFT, 		SDLK_LSHIFT, 		0, 	0 },
	{ KEYCODE_BACKSLASH,		SDLK_BACKSLASH, 	0xdc,	'\\' },
	{ KEYCODE_Z, 			SDLK_z,		     	'Z',	'Z' },
	{ KEYCODE_X, 			SDLK_x,		     	'X',	'X' },
	{ KEYCODE_C, 			SDLK_c,		     	'C',	'C' },
	{ KEYCODE_V, 			SDLK_v,		     	'V',	'V' },
	{ KEYCODE_B, 			SDLK_b,		     	'B',	'B' },
	{ KEYCODE_N, 			SDLK_n,		     	'N',	'N' },
	{ KEYCODE_M, 			SDLK_m,		     	'M',	'M' },
	{ KEYCODE_COMMA, 		SDLK_COMMA,	     	0xbc,	',' },
	{ KEYCODE_STOP, 		SDLK_PERIOD, 		0xbe,	'.' },
	{ KEYCODE_SLASH, 		SDLK_SLASH, 	     	0xbf,	'/' },
	{ KEYCODE_RSHIFT, 		SDLK_RSHIFT, 		0, 	0 },
	{ KEYCODE_ASTERISK, 		SDLK_KP_MULTIPLY,    	'*',	'*' },
	{ KEYCODE_LALT, 		SDLK_LALT, 		0, 	0 },
	{ KEYCODE_SPACE, 		SDLK_SPACE, 		' ',	' ' },
	{ KEYCODE_CAPSLOCK, 		SDLK_CAPSLOCK, 	     	0, 	0 },
	{ KEYCODE_F1, 			SDLK_F1,		0, 	0 },
	{ KEYCODE_F2, 			SDLK_F2,		0, 	0 },
	{ KEYCODE_F3, 			SDLK_F3,		0, 	0 },
	{ KEYCODE_F4, 			SDLK_F4,		0, 	0 },
	{ KEYCODE_F5, 			SDLK_F5,		0, 	0 },
	{ KEYCODE_F6, 			SDLK_F6,		0, 	0 },
	{ KEYCODE_F7, 			SDLK_F7,		0, 	0 },
	{ KEYCODE_F8, 			SDLK_F8,		0, 	0 },
	{ KEYCODE_F9, 			SDLK_F9,	    	0, 	0 },
	{ KEYCODE_F10, 			SDLK_F10,		0, 	0 },
	{ KEYCODE_NUMLOCK, 		SDLK_NUMLOCK,		0, 	0 },
	{ KEYCODE_SCRLOCK, 		SDLK_SCROLLOCK,		0, 	0 },
	{ KEYCODE_7_PAD, 		SDLK_KP7,		0, 	0 },
	{ KEYCODE_8_PAD, 		SDLK_KP8,		0, 	0 },
	{ KEYCODE_9_PAD, 		SDLK_KP9,		0, 	0 },
	{ KEYCODE_MINUS_PAD,		SDLK_KP_MINUS,	   	0, 	0 },
	{ KEYCODE_4_PAD, 		SDLK_KP4,		0, 	0 },
	{ KEYCODE_5_PAD, 		SDLK_KP5,		0, 	0 },
	{ KEYCODE_6_PAD, 		SDLK_KP6,		0, 	0 },
	{ KEYCODE_PLUS_PAD, 		SDLK_KP_PLUS,	   	0, 	0 },
	{ KEYCODE_1_PAD, 		SDLK_KP1,		0, 	0 },
	{ KEYCODE_2_PAD, 		SDLK_KP2,		0, 	0 },
	{ KEYCODE_3_PAD, 		SDLK_KP3,		0, 	0 },
	{ KEYCODE_0_PAD, 		SDLK_KP0,		0, 	0 },
	{ KEYCODE_DEL_PAD, 		SDLK_KP_PERIOD,		0, 	0 },
	{ KEYCODE_F11, 			SDLK_F11,		0,     	0 },
	{ KEYCODE_F12, 			SDLK_F12,		0,     	0 },
	{ KEYCODE_F13, 			SDLK_F13,		0,     	0 },
	{ KEYCODE_F14, 			SDLK_F14,		0,     	0 },
	{ KEYCODE_F15, 			SDLK_F15,		0,     	0 },
	{ KEYCODE_ENTER_PAD,		SDLK_KP_ENTER,		0, 	0 },
	{ KEYCODE_RCONTROL, 		SDLK_RCTRL,		0, 	0 },
	{ KEYCODE_SLASH_PAD,		SDLK_KP_DIVIDE,		0, 	0 },
	{ KEYCODE_PRTSCR, 		SDLK_PRINT, 		0, 	0 },
	{ KEYCODE_RALT, 		SDLK_RALT,		0,     	0 },
	{ KEYCODE_HOME, 		SDLK_HOME,		0,     	0 },
	{ KEYCODE_UP, 			SDLK_UP,		0,     	0 },
	{ KEYCODE_PGUP, 		SDLK_PAGEUP,		0,     	0 },
	{ KEYCODE_LEFT, 		SDLK_LEFT,		0,     	0 },
	{ KEYCODE_RIGHT, 		SDLK_RIGHT,		0,     	0 },
	{ KEYCODE_END, 			SDLK_END,		0,     	0 },
	{ KEYCODE_DOWN, 		SDLK_DOWN,		0,     	0 },
	{ KEYCODE_PGDN, 		SDLK_PAGEDOWN,		0,     	0 },
	{ KEYCODE_INSERT, 		SDLK_INSERT,		0, 	0 },
	{ KEYCODE_DEL, 			SDLK_DELETE,		0, 	0 },
	{ KEYCODE_LWIN, 		SDLK_LSUPER,		0,     	0 },
	{ KEYCODE_RWIN, 		SDLK_RSUPER,		0,     	0 },
	{ KEYCODE_MENU, 		SDLK_MENU,		0,     	0 },
	{ KEYCODE_BACKSLASH2,           SDLK_HASH,              0xdc,   '\\' },
	{ -1, -1, -1, -1 }
};

static const char *key_name_table[] =
{
	"ESC",
	"1",
	"2",
	"3",
	"4",
	"5",
	"6",
	"7",
	"8",
	"9",
	"0",
	"-",
	"=",
	"BS",
	"TAB",
	"Q",
	"W",
	"E",
	"R",
	"T",
	"Y",
	"U",
	"I",
	"O",
	"P",
	"[",
	"]",
	"ENTER",
	"LCTRL",
	"A",
	"S",
	"D",
	"F",
	"G",
	"H",
	"J",
	"K",
	"L",
	";",
	"\"",
	"`",
	"LSHIFT",
	"\\",
	"Z",
	"X",
	"C",
	"V",
	"B",
	"N",
	"M",
	",",
	".",
	"/",
	"RSHIFT",
	"*",
	"LALT",
	"SPACE",
	"CAPSLOCK",
	"F1",
	"F2",
	"F3",
	"F4",
	"F5",
	"F6",
	"F7",
	"F8",
	"F9",
	"F10",
	"NUMLOCK",
	"SCROLLLOCK",
	"KP 7",
	"KP 8",
	"KP 9",
	"KP -",
	"KP 4",
	"KP 5",
	"KP 6",
	"KP +",
	"KP 1",
	"KP 2",
	"KP 3",
	"KP 0",
	"KP .",
	"F11",
	"F12",
	"F13",
	"F14",
	"F15",
	"KP ENTER",
	"RCTRL",
	"KP /",
	"PRINTSCRN",
	"RALT",
	"HOME",
	"UP",
	"PAGEUP",
	"LEFT",
	"RIGHT",
	"END",
	"DOWN",
	"PAGEDN",
	"INS",
	"DEL",
	"LWIN",
	"RWIN",
	"MENU",
	"\\2",
	" ",
};

// master joystick translation table
static int joy_trans_table[][2] =
{
	// internal code                        MAME code
	{ JOYCODE(0, CODETYPE_AXIS_NEG, 0),		JOYCODE_1_LEFT },
	{ JOYCODE(0, CODETYPE_AXIS_POS, 0),		JOYCODE_1_RIGHT },
	{ JOYCODE(0, CODETYPE_AXIS_NEG, 1),		JOYCODE_1_UP },
	{ JOYCODE(0, CODETYPE_AXIS_POS, 1),		JOYCODE_1_DOWN },
	{ JOYCODE(0, CODETYPE_BUTTON, 0),		JOYCODE_1_BUTTON1 },
	{ JOYCODE(0, CODETYPE_BUTTON, 1),		JOYCODE_1_BUTTON2 },
	{ JOYCODE(0, CODETYPE_BUTTON, 2),		JOYCODE_1_BUTTON3 },
	{ JOYCODE(0, CODETYPE_BUTTON, 3),		JOYCODE_1_BUTTON4 },
	{ JOYCODE(0, CODETYPE_BUTTON, 4),		JOYCODE_1_BUTTON5 },
	{ JOYCODE(0, CODETYPE_BUTTON, 5),		JOYCODE_1_BUTTON6 },
	{ JOYCODE(0, CODETYPE_BUTTON, 6),		JOYCODE_1_BUTTON7 },
	{ JOYCODE(0, CODETYPE_BUTTON, 7),		JOYCODE_1_BUTTON8 },
	{ JOYCODE(0, CODETYPE_BUTTON, 8),		JOYCODE_1_BUTTON9 },
	{ JOYCODE(0, CODETYPE_BUTTON, 9),		JOYCODE_1_BUTTON10 },
	{ JOYCODE(0, CODETYPE_BUTTON, 10),		JOYCODE_1_BUTTON11 },
	{ JOYCODE(0, CODETYPE_BUTTON, 11),		JOYCODE_1_BUTTON12 },
	{ JOYCODE(0, CODETYPE_BUTTON, 12),		JOYCODE_1_BUTTON13 },
	{ JOYCODE(0, CODETYPE_BUTTON, 13),		JOYCODE_1_BUTTON14 },
	{ JOYCODE(0, CODETYPE_BUTTON, 14),		JOYCODE_1_BUTTON15 },
	{ JOYCODE(0, CODETYPE_BUTTON, 15),		JOYCODE_1_BUTTON16 },
	{ JOYCODE(0, CODETYPE_JOYAXIS, 0),		JOYCODE_1_ANALOG_X },
	{ JOYCODE(0, CODETYPE_JOYAXIS_NEG, 0),	JOYCODE_1_ANALOG_X_NEG },
	{ JOYCODE(0, CODETYPE_JOYAXIS_POS, 0),	JOYCODE_1_ANALOG_X_POS },
	{ JOYCODE(0, CODETYPE_JOYAXIS, 1),		JOYCODE_1_ANALOG_Y },
	{ JOYCODE(0, CODETYPE_JOYAXIS_NEG, 1),	JOYCODE_1_ANALOG_Y_NEG },
	{ JOYCODE(0, CODETYPE_JOYAXIS_POS, 1),	JOYCODE_1_ANALOG_Y_POS },
	{ JOYCODE(0, CODETYPE_JOYAXIS, 2),		JOYCODE_1_ANALOG_Z },
	{ JOYCODE(0, CODETYPE_JOYAXIS_NEG, 2),	JOYCODE_1_ANALOG_Z_NEG },
	{ JOYCODE(0, CODETYPE_JOYAXIS_POS, 2),	JOYCODE_1_ANALOG_Z_POS },

	{ JOYCODE(1, CODETYPE_AXIS_NEG, 0),		JOYCODE_2_LEFT },
	{ JOYCODE(1, CODETYPE_AXIS_POS, 0),		JOYCODE_2_RIGHT },
	{ JOYCODE(1, CODETYPE_AXIS_NEG, 1),		JOYCODE_2_UP },
	{ JOYCODE(1, CODETYPE_AXIS_POS, 1),		JOYCODE_2_DOWN },
	{ JOYCODE(1, CODETYPE_BUTTON, 0),		JOYCODE_2_BUTTON1 },
	{ JOYCODE(1, CODETYPE_BUTTON, 1),		JOYCODE_2_BUTTON2 },
	{ JOYCODE(1, CODETYPE_BUTTON, 2),		JOYCODE_2_BUTTON3 },
	{ JOYCODE(1, CODETYPE_BUTTON, 3),		JOYCODE_2_BUTTON4 },
	{ JOYCODE(1, CODETYPE_BUTTON, 4),		JOYCODE_2_BUTTON5 },
	{ JOYCODE(1, CODETYPE_BUTTON, 5),		JOYCODE_2_BUTTON6 },
	{ JOYCODE(1, CODETYPE_BUTTON, 6),		JOYCODE_2_BUTTON7 },
	{ JOYCODE(1, CODETYPE_BUTTON, 7),		JOYCODE_2_BUTTON8 },
	{ JOYCODE(1, CODETYPE_BUTTON, 8),		JOYCODE_2_BUTTON9 },
	{ JOYCODE(1, CODETYPE_BUTTON, 9),		JOYCODE_2_BUTTON10 },
	{ JOYCODE(1, CODETYPE_BUTTON, 10),		JOYCODE_2_BUTTON11 },
	{ JOYCODE(1, CODETYPE_BUTTON, 11),		JOYCODE_2_BUTTON12 },
	{ JOYCODE(1, CODETYPE_BUTTON, 12),		JOYCODE_2_BUTTON13 },
	{ JOYCODE(1, CODETYPE_BUTTON, 13),		JOYCODE_2_BUTTON14 },
	{ JOYCODE(1, CODETYPE_BUTTON, 14),		JOYCODE_2_BUTTON15 },
	{ JOYCODE(1, CODETYPE_BUTTON, 15),		JOYCODE_2_BUTTON16 },
	{ JOYCODE(1, CODETYPE_JOYAXIS, 0),		JOYCODE_2_ANALOG_X },
	{ JOYCODE(1, CODETYPE_JOYAXIS_NEG, 0),	JOYCODE_2_ANALOG_X_NEG },
	{ JOYCODE(1, CODETYPE_JOYAXIS_POS, 0),	JOYCODE_2_ANALOG_X_POS },
	{ JOYCODE(1, CODETYPE_JOYAXIS, 1),		JOYCODE_2_ANALOG_Y },
	{ JOYCODE(1, CODETYPE_JOYAXIS_NEG, 1),	JOYCODE_2_ANALOG_Y_NEG },
	{ JOYCODE(1, CODETYPE_JOYAXIS_POS, 1),	JOYCODE_2_ANALOG_Y_POS },
	{ JOYCODE(1, CODETYPE_JOYAXIS, 2),		JOYCODE_2_ANALOG_Z },
	{ JOYCODE(1, CODETYPE_JOYAXIS_NEG, 2),	JOYCODE_2_ANALOG_Z_NEG },
	{ JOYCODE(1, CODETYPE_JOYAXIS_POS, 2),	JOYCODE_2_ANALOG_Z_POS },

	{ JOYCODE(2, CODETYPE_AXIS_NEG, 0),		JOYCODE_3_LEFT },
	{ JOYCODE(2, CODETYPE_AXIS_POS, 0),		JOYCODE_3_RIGHT },
	{ JOYCODE(2, CODETYPE_AXIS_NEG, 1),		JOYCODE_3_UP },
	{ JOYCODE(2, CODETYPE_AXIS_POS, 1),		JOYCODE_3_DOWN },
	{ JOYCODE(2, CODETYPE_BUTTON, 0),		JOYCODE_3_BUTTON1 },
	{ JOYCODE(2, CODETYPE_BUTTON, 1),		JOYCODE_3_BUTTON2 },
	{ JOYCODE(2, CODETYPE_BUTTON, 2),		JOYCODE_3_BUTTON3 },
	{ JOYCODE(2, CODETYPE_BUTTON, 3),		JOYCODE_3_BUTTON4 },
	{ JOYCODE(2, CODETYPE_BUTTON, 4),		JOYCODE_3_BUTTON5 },
	{ JOYCODE(2, CODETYPE_BUTTON, 5),		JOYCODE_3_BUTTON6 },
	{ JOYCODE(2, CODETYPE_BUTTON, 6),		JOYCODE_3_BUTTON7 },
	{ JOYCODE(2, CODETYPE_BUTTON, 7),		JOYCODE_3_BUTTON8 },
	{ JOYCODE(2, CODETYPE_BUTTON, 8),		JOYCODE_3_BUTTON9 },
	{ JOYCODE(2, CODETYPE_BUTTON, 9),		JOYCODE_3_BUTTON10 },
	{ JOYCODE(2, CODETYPE_BUTTON, 10),		JOYCODE_3_BUTTON11 },
	{ JOYCODE(2, CODETYPE_BUTTON, 11),		JOYCODE_3_BUTTON12 },
	{ JOYCODE(2, CODETYPE_BUTTON, 12),		JOYCODE_3_BUTTON13 },
	{ JOYCODE(2, CODETYPE_BUTTON, 13),		JOYCODE_3_BUTTON14 },
	{ JOYCODE(2, CODETYPE_BUTTON, 14),		JOYCODE_3_BUTTON15 },
	{ JOYCODE(2, CODETYPE_BUTTON, 15),		JOYCODE_3_BUTTON16 },
	{ JOYCODE(2, CODETYPE_JOYAXIS, 0),		JOYCODE_3_ANALOG_X },
	{ JOYCODE(2, CODETYPE_JOYAXIS_NEG, 0),	JOYCODE_3_ANALOG_X_NEG },
	{ JOYCODE(2, CODETYPE_JOYAXIS_POS, 0),	JOYCODE_3_ANALOG_X_POS },
	{ JOYCODE(2, CODETYPE_JOYAXIS, 1),		JOYCODE_3_ANALOG_Y },
	{ JOYCODE(2, CODETYPE_JOYAXIS_NEG, 1),	JOYCODE_3_ANALOG_Y_NEG },
	{ JOYCODE(2, CODETYPE_JOYAXIS_POS, 1),	JOYCODE_3_ANALOG_Y_POS },
	{ JOYCODE(2, CODETYPE_JOYAXIS, 2),		JOYCODE_3_ANALOG_Z },
	{ JOYCODE(2, CODETYPE_JOYAXIS_NEG, 2),	JOYCODE_3_ANALOG_Z_NEG },
	{ JOYCODE(2, CODETYPE_JOYAXIS_POS, 2),	JOYCODE_3_ANALOG_Z_POS },

	{ JOYCODE(3, CODETYPE_AXIS_NEG, 0),		JOYCODE_4_LEFT },
	{ JOYCODE(3, CODETYPE_AXIS_POS, 0),		JOYCODE_4_RIGHT },
	{ JOYCODE(3, CODETYPE_AXIS_NEG, 1),		JOYCODE_4_UP },
	{ JOYCODE(3, CODETYPE_AXIS_POS, 1),		JOYCODE_4_DOWN },
	{ JOYCODE(3, CODETYPE_BUTTON, 0),		JOYCODE_4_BUTTON1 },
	{ JOYCODE(3, CODETYPE_BUTTON, 1),		JOYCODE_4_BUTTON2 },
	{ JOYCODE(3, CODETYPE_BUTTON, 2),		JOYCODE_4_BUTTON3 },
	{ JOYCODE(3, CODETYPE_BUTTON, 3),		JOYCODE_4_BUTTON4 },
	{ JOYCODE(3, CODETYPE_BUTTON, 4),		JOYCODE_4_BUTTON5 },
	{ JOYCODE(3, CODETYPE_BUTTON, 5),		JOYCODE_4_BUTTON6 },
	{ JOYCODE(3, CODETYPE_BUTTON, 6),		JOYCODE_4_BUTTON7 },
	{ JOYCODE(3, CODETYPE_BUTTON, 7),		JOYCODE_4_BUTTON8 },
	{ JOYCODE(3, CODETYPE_BUTTON, 8),		JOYCODE_4_BUTTON9 },
	{ JOYCODE(3, CODETYPE_BUTTON, 9),		JOYCODE_4_BUTTON10 },
	{ JOYCODE(3, CODETYPE_BUTTON, 10),		JOYCODE_4_BUTTON11 },
	{ JOYCODE(3, CODETYPE_BUTTON, 11),		JOYCODE_4_BUTTON12 },
	{ JOYCODE(3, CODETYPE_BUTTON, 12),		JOYCODE_4_BUTTON13 },
	{ JOYCODE(3, CODETYPE_BUTTON, 13),		JOYCODE_4_BUTTON14 },
	{ JOYCODE(3, CODETYPE_BUTTON, 14),		JOYCODE_4_BUTTON15 },
	{ JOYCODE(3, CODETYPE_BUTTON, 15),		JOYCODE_4_BUTTON16 },
	{ JOYCODE(3, CODETYPE_JOYAXIS, 0),		JOYCODE_4_ANALOG_X },
	{ JOYCODE(3, CODETYPE_JOYAXIS_NEG, 0),	JOYCODE_4_ANALOG_X_NEG },
	{ JOYCODE(3, CODETYPE_JOYAXIS_POS, 0),	JOYCODE_4_ANALOG_X_POS },
	{ JOYCODE(3, CODETYPE_JOYAXIS, 1),		JOYCODE_4_ANALOG_Y },
	{ JOYCODE(3, CODETYPE_JOYAXIS_NEG, 1),	JOYCODE_4_ANALOG_Y_NEG },
	{ JOYCODE(3, CODETYPE_JOYAXIS_POS, 1),	JOYCODE_4_ANALOG_Y_POS },
	{ JOYCODE(3, CODETYPE_JOYAXIS, 2),		JOYCODE_4_ANALOG_Z },
	{ JOYCODE(3, CODETYPE_JOYAXIS_NEG, 2),	JOYCODE_4_ANALOG_Z_NEG },
	{ JOYCODE(3, CODETYPE_JOYAXIS_POS, 2),	JOYCODE_4_ANALOG_Z_POS },

	{ JOYCODE(4, CODETYPE_AXIS_NEG, 0),		JOYCODE_5_LEFT },
	{ JOYCODE(4, CODETYPE_AXIS_POS, 0),		JOYCODE_5_RIGHT },
	{ JOYCODE(4, CODETYPE_AXIS_NEG, 1),		JOYCODE_5_UP },
	{ JOYCODE(4, CODETYPE_AXIS_POS, 1),		JOYCODE_5_DOWN },
	{ JOYCODE(4, CODETYPE_BUTTON, 0),		JOYCODE_5_BUTTON1 },
	{ JOYCODE(4, CODETYPE_BUTTON, 1),		JOYCODE_5_BUTTON2 },
	{ JOYCODE(4, CODETYPE_BUTTON, 2),		JOYCODE_5_BUTTON3 },
	{ JOYCODE(4, CODETYPE_BUTTON, 3),		JOYCODE_5_BUTTON4 },
	{ JOYCODE(4, CODETYPE_BUTTON, 4),		JOYCODE_5_BUTTON5 },
	{ JOYCODE(4, CODETYPE_BUTTON, 5),		JOYCODE_5_BUTTON6 },
	{ JOYCODE(4, CODETYPE_BUTTON, 6),		JOYCODE_5_BUTTON7 },
	{ JOYCODE(4, CODETYPE_BUTTON, 7),		JOYCODE_5_BUTTON8 },
	{ JOYCODE(4, CODETYPE_BUTTON, 8),		JOYCODE_5_BUTTON9 },
	{ JOYCODE(4, CODETYPE_BUTTON, 9),		JOYCODE_5_BUTTON10 },
	{ JOYCODE(4, CODETYPE_BUTTON, 10),		JOYCODE_5_BUTTON11 },
	{ JOYCODE(4, CODETYPE_BUTTON, 11),		JOYCODE_5_BUTTON12 },
	{ JOYCODE(4, CODETYPE_BUTTON, 12),		JOYCODE_5_BUTTON13 },
	{ JOYCODE(4, CODETYPE_BUTTON, 13),		JOYCODE_5_BUTTON14 },
	{ JOYCODE(4, CODETYPE_BUTTON, 14),		JOYCODE_5_BUTTON15 },
	{ JOYCODE(4, CODETYPE_BUTTON, 15),		JOYCODE_5_BUTTON16 },
	{ JOYCODE(4, CODETYPE_JOYAXIS, 0),		JOYCODE_5_ANALOG_X },
	{ JOYCODE(4, CODETYPE_JOYAXIS_NEG, 0),	JOYCODE_5_ANALOG_X_NEG },
	{ JOYCODE(4, CODETYPE_JOYAXIS_POS, 0),	JOYCODE_5_ANALOG_X_POS },
	{ JOYCODE(4, CODETYPE_JOYAXIS, 1),		JOYCODE_5_ANALOG_Y },
	{ JOYCODE(4, CODETYPE_JOYAXIS_NEG, 1),	JOYCODE_5_ANALOG_Y_NEG },
	{ JOYCODE(4, CODETYPE_JOYAXIS_POS, 1),	JOYCODE_5_ANALOG_Y_POS },
	{ JOYCODE(4, CODETYPE_JOYAXIS, 2),		JOYCODE_5_ANALOG_Z },
	{ JOYCODE(4, CODETYPE_JOYAXIS_NEG, 2),	JOYCODE_5_ANALOG_Z_NEG },
	{ JOYCODE(4, CODETYPE_JOYAXIS_POS, 2),	JOYCODE_5_ANALOG_Z_POS },

	{ JOYCODE(5, CODETYPE_AXIS_NEG, 0),		JOYCODE_6_LEFT },
	{ JOYCODE(5, CODETYPE_AXIS_POS, 0),		JOYCODE_6_RIGHT },
	{ JOYCODE(5, CODETYPE_AXIS_NEG, 1),		JOYCODE_6_UP },
	{ JOYCODE(5, CODETYPE_AXIS_POS, 1),		JOYCODE_6_DOWN },
	{ JOYCODE(5, CODETYPE_BUTTON, 0),		JOYCODE_6_BUTTON1 },
	{ JOYCODE(5, CODETYPE_BUTTON, 1),		JOYCODE_6_BUTTON2 },
	{ JOYCODE(5, CODETYPE_BUTTON, 2),		JOYCODE_6_BUTTON3 },
	{ JOYCODE(5, CODETYPE_BUTTON, 3),		JOYCODE_6_BUTTON4 },
	{ JOYCODE(5, CODETYPE_BUTTON, 4),		JOYCODE_6_BUTTON5 },
	{ JOYCODE(5, CODETYPE_BUTTON, 5),		JOYCODE_6_BUTTON6 },
	{ JOYCODE(5, CODETYPE_BUTTON, 6),		JOYCODE_6_BUTTON7 },
	{ JOYCODE(5, CODETYPE_BUTTON, 7),		JOYCODE_6_BUTTON8 },
	{ JOYCODE(5, CODETYPE_BUTTON, 8),		JOYCODE_6_BUTTON9 },
	{ JOYCODE(5, CODETYPE_BUTTON, 9),		JOYCODE_6_BUTTON10 },
	{ JOYCODE(5, CODETYPE_BUTTON, 10),		JOYCODE_6_BUTTON11 },
	{ JOYCODE(5, CODETYPE_BUTTON, 11),		JOYCODE_6_BUTTON12 },
	{ JOYCODE(5, CODETYPE_BUTTON, 12),		JOYCODE_6_BUTTON13 },
	{ JOYCODE(5, CODETYPE_BUTTON, 13),		JOYCODE_6_BUTTON14 },
	{ JOYCODE(5, CODETYPE_BUTTON, 14),		JOYCODE_6_BUTTON15 },
	{ JOYCODE(5, CODETYPE_BUTTON, 15),		JOYCODE_6_BUTTON16 },
	{ JOYCODE(5, CODETYPE_JOYAXIS, 0),		JOYCODE_6_ANALOG_X },
	{ JOYCODE(5, CODETYPE_JOYAXIS_NEG, 0),	JOYCODE_6_ANALOG_X_NEG },
	{ JOYCODE(5, CODETYPE_JOYAXIS_POS, 0),	JOYCODE_6_ANALOG_X_POS },
	{ JOYCODE(5, CODETYPE_JOYAXIS, 1),		JOYCODE_6_ANALOG_Y },
	{ JOYCODE(5, CODETYPE_JOYAXIS_NEG, 1),	JOYCODE_6_ANALOG_Y_NEG },
	{ JOYCODE(5, CODETYPE_JOYAXIS_POS, 1),	JOYCODE_6_ANALOG_Y_POS },
	{ JOYCODE(5, CODETYPE_JOYAXIS, 2),		JOYCODE_6_ANALOG_Z },
	{ JOYCODE(5, CODETYPE_JOYAXIS_NEG, 2),	JOYCODE_6_ANALOG_Z_NEG },
	{ JOYCODE(5, CODETYPE_JOYAXIS_POS, 2),	JOYCODE_6_ANALOG_Z_POS },

	{ JOYCODE(6, CODETYPE_AXIS_NEG, 0),		JOYCODE_7_LEFT },
	{ JOYCODE(6, CODETYPE_AXIS_POS, 0),		JOYCODE_7_RIGHT },
	{ JOYCODE(6, CODETYPE_AXIS_NEG, 1),		JOYCODE_7_UP },
	{ JOYCODE(6, CODETYPE_AXIS_POS, 1),		JOYCODE_7_DOWN },
	{ JOYCODE(6, CODETYPE_BUTTON, 0),		JOYCODE_7_BUTTON1 },
	{ JOYCODE(6, CODETYPE_BUTTON, 1),		JOYCODE_7_BUTTON2 },
	{ JOYCODE(6, CODETYPE_BUTTON, 2),		JOYCODE_7_BUTTON3 },
	{ JOYCODE(6, CODETYPE_BUTTON, 3),		JOYCODE_7_BUTTON4 },
	{ JOYCODE(6, CODETYPE_BUTTON, 4),		JOYCODE_7_BUTTON5 },
	{ JOYCODE(6, CODETYPE_BUTTON, 5),		JOYCODE_7_BUTTON6 },
	{ JOYCODE(6, CODETYPE_BUTTON, 6),		JOYCODE_7_BUTTON7 },
	{ JOYCODE(6, CODETYPE_BUTTON, 7),		JOYCODE_7_BUTTON8 },
	{ JOYCODE(6, CODETYPE_BUTTON, 8),		JOYCODE_7_BUTTON9 },
	{ JOYCODE(6, CODETYPE_BUTTON, 9),		JOYCODE_7_BUTTON10 },
	{ JOYCODE(6, CODETYPE_BUTTON, 10),		JOYCODE_7_BUTTON11 },
	{ JOYCODE(6, CODETYPE_BUTTON, 11),		JOYCODE_7_BUTTON12 },
	{ JOYCODE(6, CODETYPE_BUTTON, 12),		JOYCODE_7_BUTTON13 },
	{ JOYCODE(6, CODETYPE_BUTTON, 13),		JOYCODE_7_BUTTON14 },
	{ JOYCODE(6, CODETYPE_BUTTON, 14),		JOYCODE_7_BUTTON15 },
	{ JOYCODE(6, CODETYPE_BUTTON, 15),		JOYCODE_7_BUTTON16 },
	{ JOYCODE(6, CODETYPE_JOYAXIS, 0),		JOYCODE_7_ANALOG_X },
	{ JOYCODE(6, CODETYPE_JOYAXIS_NEG, 0),	JOYCODE_7_ANALOG_X_NEG },
	{ JOYCODE(6, CODETYPE_JOYAXIS_POS, 0),	JOYCODE_7_ANALOG_X_POS },
	{ JOYCODE(6, CODETYPE_JOYAXIS, 1),		JOYCODE_7_ANALOG_Y },
	{ JOYCODE(6, CODETYPE_JOYAXIS_NEG, 1),	JOYCODE_7_ANALOG_Y_NEG },
	{ JOYCODE(6, CODETYPE_JOYAXIS_POS, 1),	JOYCODE_7_ANALOG_Y_POS },
	{ JOYCODE(6, CODETYPE_JOYAXIS, 2),		JOYCODE_7_ANALOG_Z },
	{ JOYCODE(6, CODETYPE_JOYAXIS_NEG, 2),	JOYCODE_7_ANALOG_Z_NEG },
	{ JOYCODE(6, CODETYPE_JOYAXIS_POS, 2),	JOYCODE_7_ANALOG_Z_POS },

	{ JOYCODE(7, CODETYPE_AXIS_NEG, 0),		JOYCODE_8_LEFT },
	{ JOYCODE(7, CODETYPE_AXIS_POS, 0),		JOYCODE_8_RIGHT },
	{ JOYCODE(7, CODETYPE_AXIS_NEG, 1),		JOYCODE_8_UP },
	{ JOYCODE(7, CODETYPE_AXIS_POS, 1),		JOYCODE_8_DOWN },
	{ JOYCODE(7, CODETYPE_BUTTON, 0),		JOYCODE_8_BUTTON1 },
	{ JOYCODE(7, CODETYPE_BUTTON, 1),		JOYCODE_8_BUTTON2 },
	{ JOYCODE(7, CODETYPE_BUTTON, 2),		JOYCODE_8_BUTTON3 },
	{ JOYCODE(7, CODETYPE_BUTTON, 3),		JOYCODE_8_BUTTON4 },
	{ JOYCODE(7, CODETYPE_BUTTON, 4),		JOYCODE_8_BUTTON5 },
	{ JOYCODE(7, CODETYPE_BUTTON, 5),		JOYCODE_8_BUTTON6 },
	{ JOYCODE(7, CODETYPE_BUTTON, 6),		JOYCODE_8_BUTTON7 },
	{ JOYCODE(7, CODETYPE_BUTTON, 7),		JOYCODE_8_BUTTON8 },
	{ JOYCODE(7, CODETYPE_BUTTON, 8),		JOYCODE_8_BUTTON9 },
	{ JOYCODE(7, CODETYPE_BUTTON, 9),		JOYCODE_8_BUTTON10 },
	{ JOYCODE(7, CODETYPE_BUTTON, 10),		JOYCODE_8_BUTTON11 },
	{ JOYCODE(7, CODETYPE_BUTTON, 11),		JOYCODE_8_BUTTON12 },
	{ JOYCODE(7, CODETYPE_BUTTON, 12),		JOYCODE_8_BUTTON13 },
	{ JOYCODE(7, CODETYPE_BUTTON, 13),		JOYCODE_8_BUTTON14 },
	{ JOYCODE(7, CODETYPE_BUTTON, 14),		JOYCODE_8_BUTTON15 },
	{ JOYCODE(7, CODETYPE_BUTTON, 15),		JOYCODE_8_BUTTON16 },
	{ JOYCODE(7, CODETYPE_JOYAXIS, 0),		JOYCODE_8_ANALOG_X },
	{ JOYCODE(7, CODETYPE_JOYAXIS_NEG, 0),	JOYCODE_8_ANALOG_X_NEG },
	{ JOYCODE(7, CODETYPE_JOYAXIS_POS, 0),	JOYCODE_8_ANALOG_X_POS },
	{ JOYCODE(7, CODETYPE_JOYAXIS, 1),		JOYCODE_8_ANALOG_Y },
	{ JOYCODE(7, CODETYPE_JOYAXIS_NEG, 1),	JOYCODE_8_ANALOG_Y_NEG },
	{ JOYCODE(7, CODETYPE_JOYAXIS_POS, 1),	JOYCODE_8_ANALOG_Y_POS },
	{ JOYCODE(7, CODETYPE_JOYAXIS, 2),		JOYCODE_8_ANALOG_Z },
	{ JOYCODE(7, CODETYPE_JOYAXIS_NEG, 2),	JOYCODE_8_ANALOG_Z_NEG },
	{ JOYCODE(7, CODETYPE_JOYAXIS_POS, 2),	JOYCODE_8_ANALOG_Z_POS },

	{ JOYCODE(0, CODETYPE_MOUSEBUTTON, 0), 	MOUSECODE_1_BUTTON1 },
	{ JOYCODE(0, CODETYPE_MOUSEBUTTON, 1), 	MOUSECODE_1_BUTTON2 },
	{ JOYCODE(0, CODETYPE_MOUSEBUTTON, 2), 	MOUSECODE_1_BUTTON3 },
	{ JOYCODE(0, CODETYPE_MOUSEBUTTON, 3), 	MOUSECODE_1_BUTTON4 },
	{ JOYCODE(0, CODETYPE_MOUSEBUTTON, 4), 	MOUSECODE_1_BUTTON5 },
	{ JOYCODE(0, CODETYPE_MOUSEAXIS, 0),	MOUSECODE_1_ANALOG_X },
	{ JOYCODE(0, CODETYPE_MOUSEAXIS, 1),	MOUSECODE_1_ANALOG_Y },
	{ JOYCODE(0, CODETYPE_MOUSEAXIS, 2),	MOUSECODE_1_ANALOG_Z },
	{ JOYCODE(0, CODETYPE_MOUSE_NEG, 0),	MOUSECODE_1_X_NEG },
	{ JOYCODE(0, CODETYPE_MOUSE_POS, 0),	MOUSECODE_1_X_POS },
	{ JOYCODE(0, CODETYPE_MOUSE_NEG, 1),	MOUSECODE_1_Y_NEG },
	{ JOYCODE(0, CODETYPE_MOUSE_POS, 1),	MOUSECODE_1_Y_POS },
	{ JOYCODE(0, CODETYPE_MOUSE_NEG, 2),	MOUSECODE_1_Z_NEG },
	{ JOYCODE(0, CODETYPE_MOUSE_POS, 2),	MOUSECODE_1_Z_POS },

	{ JOYCODE(1, CODETYPE_MOUSEBUTTON, 0), 	MOUSECODE_2_BUTTON1 },
	{ JOYCODE(1, CODETYPE_MOUSEBUTTON, 1), 	MOUSECODE_2_BUTTON2 },
	{ JOYCODE(1, CODETYPE_MOUSEBUTTON, 2), 	MOUSECODE_2_BUTTON3 },
	{ JOYCODE(1, CODETYPE_MOUSEBUTTON, 3), 	MOUSECODE_2_BUTTON4 },
	{ JOYCODE(1, CODETYPE_MOUSEBUTTON, 4), 	MOUSECODE_2_BUTTON5 },
	{ JOYCODE(1, CODETYPE_MOUSEAXIS, 0),	MOUSECODE_2_ANALOG_X },
	{ JOYCODE(1, CODETYPE_MOUSEAXIS, 1),	MOUSECODE_2_ANALOG_Y },
	{ JOYCODE(1, CODETYPE_MOUSEAXIS, 2),	MOUSECODE_2_ANALOG_Z },
	{ JOYCODE(1, CODETYPE_MOUSE_NEG, 0),	MOUSECODE_2_X_NEG },
	{ JOYCODE(1, CODETYPE_MOUSE_POS, 0),	MOUSECODE_2_X_POS },
	{ JOYCODE(1, CODETYPE_MOUSE_NEG, 1),	MOUSECODE_2_Y_NEG },
	{ JOYCODE(1, CODETYPE_MOUSE_POS, 1),	MOUSECODE_2_Y_POS },
	{ JOYCODE(1, CODETYPE_MOUSE_NEG, 2),	MOUSECODE_2_Z_NEG },
	{ JOYCODE(1, CODETYPE_MOUSE_POS, 2),	MOUSECODE_2_Z_POS },

	{ JOYCODE(2, CODETYPE_MOUSEBUTTON, 0), 	MOUSECODE_3_BUTTON1 },
	{ JOYCODE(2, CODETYPE_MOUSEBUTTON, 1), 	MOUSECODE_3_BUTTON2 },
	{ JOYCODE(2, CODETYPE_MOUSEBUTTON, 2), 	MOUSECODE_3_BUTTON3 },
	{ JOYCODE(2, CODETYPE_MOUSEBUTTON, 3), 	MOUSECODE_3_BUTTON4 },
	{ JOYCODE(2, CODETYPE_MOUSEBUTTON, 4), 	MOUSECODE_3_BUTTON5 },
	{ JOYCODE(2, CODETYPE_MOUSEAXIS, 0),	MOUSECODE_3_ANALOG_X },
	{ JOYCODE(2, CODETYPE_MOUSEAXIS, 1),	MOUSECODE_3_ANALOG_Y },
	{ JOYCODE(2, CODETYPE_MOUSEAXIS, 2),	MOUSECODE_3_ANALOG_Z },
	{ JOYCODE(2, CODETYPE_MOUSE_NEG, 0),	MOUSECODE_3_X_NEG },
	{ JOYCODE(2, CODETYPE_MOUSE_POS, 0),	MOUSECODE_3_X_POS },
	{ JOYCODE(2, CODETYPE_MOUSE_NEG, 1),	MOUSECODE_3_Y_NEG },
	{ JOYCODE(2, CODETYPE_MOUSE_POS, 1),	MOUSECODE_3_Y_POS },
	{ JOYCODE(2, CODETYPE_MOUSE_NEG, 2),	MOUSECODE_3_Z_NEG },
	{ JOYCODE(2, CODETYPE_MOUSE_POS, 2),	MOUSECODE_3_Z_POS },

	{ JOYCODE(3, CODETYPE_MOUSEBUTTON, 0), 	MOUSECODE_4_BUTTON1 },
	{ JOYCODE(3, CODETYPE_MOUSEBUTTON, 1), 	MOUSECODE_4_BUTTON2 },
	{ JOYCODE(3, CODETYPE_MOUSEBUTTON, 2), 	MOUSECODE_4_BUTTON3 },
	{ JOYCODE(3, CODETYPE_MOUSEBUTTON, 3), 	MOUSECODE_4_BUTTON4 },
	{ JOYCODE(3, CODETYPE_MOUSEBUTTON, 4), 	MOUSECODE_4_BUTTON5 },
	{ JOYCODE(3, CODETYPE_MOUSEAXIS, 0),	MOUSECODE_4_ANALOG_X },
	{ JOYCODE(3, CODETYPE_MOUSEAXIS, 1),	MOUSECODE_4_ANALOG_Y },
	{ JOYCODE(3, CODETYPE_MOUSEAXIS, 2),	MOUSECODE_4_ANALOG_Z },
	{ JOYCODE(3, CODETYPE_MOUSE_NEG, 0),	MOUSECODE_4_X_NEG },
	{ JOYCODE(3, CODETYPE_MOUSE_POS, 0),	MOUSECODE_4_X_POS },
	{ JOYCODE(3, CODETYPE_MOUSE_NEG, 1),	MOUSECODE_4_Y_NEG },
	{ JOYCODE(3, CODETYPE_MOUSE_POS, 1),	MOUSECODE_4_Y_POS },
	{ JOYCODE(3, CODETYPE_MOUSE_NEG, 2),	MOUSECODE_4_Z_NEG },
	{ JOYCODE(3, CODETYPE_MOUSE_POS, 2),	MOUSECODE_4_Z_POS },

	{ JOYCODE(4, CODETYPE_MOUSEBUTTON, 0), 	MOUSECODE_5_BUTTON1 },
	{ JOYCODE(4, CODETYPE_MOUSEBUTTON, 1), 	MOUSECODE_5_BUTTON2 },
	{ JOYCODE(4, CODETYPE_MOUSEBUTTON, 2), 	MOUSECODE_5_BUTTON3 },
	{ JOYCODE(4, CODETYPE_MOUSEBUTTON, 3), 	MOUSECODE_5_BUTTON4 },
	{ JOYCODE(4, CODETYPE_MOUSEBUTTON, 4), 	MOUSECODE_5_BUTTON5 },
	{ JOYCODE(4, CODETYPE_MOUSEAXIS, 0),	MOUSECODE_5_ANALOG_X },
	{ JOYCODE(4, CODETYPE_MOUSEAXIS, 1),	MOUSECODE_5_ANALOG_Y },
	{ JOYCODE(4, CODETYPE_MOUSEAXIS, 2),	MOUSECODE_5_ANALOG_Z },
	{ JOYCODE(4, CODETYPE_MOUSE_NEG, 0),	MOUSECODE_5_X_NEG },
	{ JOYCODE(4, CODETYPE_MOUSE_POS, 0),	MOUSECODE_5_X_POS },
	{ JOYCODE(4, CODETYPE_MOUSE_NEG, 1),	MOUSECODE_5_Y_NEG },
	{ JOYCODE(4, CODETYPE_MOUSE_POS, 1),	MOUSECODE_5_Y_POS },
	{ JOYCODE(4, CODETYPE_MOUSE_NEG, 2),	MOUSECODE_5_Z_NEG },
	{ JOYCODE(4, CODETYPE_MOUSE_POS, 2),	MOUSECODE_5_Z_POS },

	{ JOYCODE(5, CODETYPE_MOUSEBUTTON, 0), 	MOUSECODE_6_BUTTON1 },
	{ JOYCODE(5, CODETYPE_MOUSEBUTTON, 1), 	MOUSECODE_6_BUTTON2 },
	{ JOYCODE(5, CODETYPE_MOUSEBUTTON, 2), 	MOUSECODE_6_BUTTON3 },
	{ JOYCODE(5, CODETYPE_MOUSEBUTTON, 3), 	MOUSECODE_6_BUTTON4 },
	{ JOYCODE(5, CODETYPE_MOUSEBUTTON, 4), 	MOUSECODE_6_BUTTON5 },
	{ JOYCODE(5, CODETYPE_MOUSEAXIS, 0),	MOUSECODE_6_ANALOG_X },
	{ JOYCODE(5, CODETYPE_MOUSEAXIS, 1),	MOUSECODE_6_ANALOG_Y },
	{ JOYCODE(5, CODETYPE_MOUSEAXIS, 2),	MOUSECODE_6_ANALOG_Z },
	{ JOYCODE(5, CODETYPE_MOUSE_NEG, 0),	MOUSECODE_6_X_NEG },
	{ JOYCODE(5, CODETYPE_MOUSE_POS, 0),	MOUSECODE_6_X_POS },
	{ JOYCODE(5, CODETYPE_MOUSE_NEG, 1),	MOUSECODE_6_Y_NEG },
	{ JOYCODE(5, CODETYPE_MOUSE_POS, 1),	MOUSECODE_6_Y_POS },
	{ JOYCODE(5, CODETYPE_MOUSE_NEG, 2),	MOUSECODE_6_Z_NEG },
	{ JOYCODE(5, CODETYPE_MOUSE_POS, 2),	MOUSECODE_6_Z_POS },

	{ JOYCODE(6, CODETYPE_MOUSEBUTTON, 0), 	MOUSECODE_7_BUTTON1 },
	{ JOYCODE(6, CODETYPE_MOUSEBUTTON, 1), 	MOUSECODE_7_BUTTON2 },
	{ JOYCODE(6, CODETYPE_MOUSEBUTTON, 2), 	MOUSECODE_7_BUTTON3 },
	{ JOYCODE(6, CODETYPE_MOUSEBUTTON, 3), 	MOUSECODE_7_BUTTON4 },
	{ JOYCODE(6, CODETYPE_MOUSEBUTTON, 4), 	MOUSECODE_7_BUTTON5 },
	{ JOYCODE(6, CODETYPE_MOUSEAXIS, 0),	MOUSECODE_7_ANALOG_X },
	{ JOYCODE(6, CODETYPE_MOUSEAXIS, 1),	MOUSECODE_7_ANALOG_Y },
	{ JOYCODE(6, CODETYPE_MOUSEAXIS, 2),	MOUSECODE_7_ANALOG_Z },
	{ JOYCODE(6, CODETYPE_MOUSE_NEG, 0),	MOUSECODE_7_X_NEG },
	{ JOYCODE(6, CODETYPE_MOUSE_POS, 0),	MOUSECODE_7_X_POS },
	{ JOYCODE(6, CODETYPE_MOUSE_NEG, 1),	MOUSECODE_7_Y_NEG },
	{ JOYCODE(6, CODETYPE_MOUSE_POS, 1),	MOUSECODE_7_Y_POS },
	{ JOYCODE(6, CODETYPE_MOUSE_NEG, 2),	MOUSECODE_7_Z_NEG },
	{ JOYCODE(6, CODETYPE_MOUSE_POS, 2),	MOUSECODE_7_Z_POS },

	{ JOYCODE(7, CODETYPE_MOUSEBUTTON, 0), 	MOUSECODE_8_BUTTON1 },
	{ JOYCODE(7, CODETYPE_MOUSEBUTTON, 1), 	MOUSECODE_8_BUTTON2 },
	{ JOYCODE(7, CODETYPE_MOUSEBUTTON, 2), 	MOUSECODE_8_BUTTON3 },
	{ JOYCODE(7, CODETYPE_MOUSEBUTTON, 3), 	MOUSECODE_8_BUTTON4 },
	{ JOYCODE(7, CODETYPE_MOUSEBUTTON, 4), 	MOUSECODE_8_BUTTON5 },
	{ JOYCODE(7, CODETYPE_MOUSEAXIS, 0),	MOUSECODE_8_ANALOG_X },
	{ JOYCODE(7, CODETYPE_MOUSEAXIS, 1),	MOUSECODE_8_ANALOG_Y },
	{ JOYCODE(7, CODETYPE_MOUSEAXIS, 2),	MOUSECODE_8_ANALOG_Z },
	{ JOYCODE(7, CODETYPE_MOUSE_NEG, 0),	MOUSECODE_8_X_NEG },
	{ JOYCODE(7, CODETYPE_MOUSE_POS, 0),	MOUSECODE_8_X_POS },
	{ JOYCODE(7, CODETYPE_MOUSE_NEG, 1),	MOUSECODE_8_Y_NEG },
	{ JOYCODE(7, CODETYPE_MOUSE_POS, 1),	MOUSECODE_8_Y_POS },
	{ JOYCODE(7, CODETYPE_MOUSE_NEG, 2),	MOUSECODE_8_Z_NEG },
	{ JOYCODE(7, CODETYPE_MOUSE_POS, 2),	MOUSECODE_8_Z_POS },

	{ JOYCODE(0, CODETYPE_GUNAXIS, 0),		GUNCODE_1_ANALOG_X },
	{ JOYCODE(0, CODETYPE_GUNAXIS, 1),		GUNCODE_1_ANALOG_Y },

	{ JOYCODE(1, CODETYPE_GUNAXIS, 0),		GUNCODE_2_ANALOG_X },
	{ JOYCODE(1, CODETYPE_GUNAXIS, 1),		GUNCODE_2_ANALOG_Y },

	{ JOYCODE(2, CODETYPE_GUNAXIS, 0),		GUNCODE_3_ANALOG_X },
	{ JOYCODE(2, CODETYPE_GUNAXIS, 1),		GUNCODE_3_ANALOG_Y },

	{ JOYCODE(3, CODETYPE_GUNAXIS, 0),		GUNCODE_4_ANALOG_X },
	{ JOYCODE(3, CODETYPE_GUNAXIS, 1),		GUNCODE_4_ANALOG_Y },

	{ JOYCODE(4, CODETYPE_GUNAXIS, 0),		GUNCODE_5_ANALOG_X },
	{ JOYCODE(4, CODETYPE_GUNAXIS, 1),		GUNCODE_5_ANALOG_Y },

	{ JOYCODE(5, CODETYPE_GUNAXIS, 0),		GUNCODE_6_ANALOG_X },
	{ JOYCODE(5, CODETYPE_GUNAXIS, 1),		GUNCODE_6_ANALOG_Y },

	{ JOYCODE(6, CODETYPE_GUNAXIS, 0),		GUNCODE_7_ANALOG_X },
	{ JOYCODE(6, CODETYPE_GUNAXIS, 1),		GUNCODE_7_ANALOG_Y },

	{ JOYCODE(7, CODETYPE_GUNAXIS, 0),		GUNCODE_8_ANALOG_X },
	{ JOYCODE(7, CODETYPE_GUNAXIS, 1),		GUNCODE_8_ANALOG_Y },
};

typedef struct _key_lookup_table key_lookup_table;

struct _key_lookup_table 
{
	int code;
	const char *name;
};

#define KE(x) { x, #x }

static key_lookup_table sdl_lookup[] =
{
	KE(SDLK_UNKNOWN),
	KE(SDLK_FIRST),
	KE(SDLK_BACKSPACE),
	KE(SDLK_TAB),
	KE(SDLK_CLEAR),
	KE(SDLK_RETURN),
	KE(SDLK_PAUSE),
	KE(SDLK_ESCAPE),
	KE(SDLK_SPACE),
	KE(SDLK_EXCLAIM),
	KE(SDLK_QUOTEDBL),
	KE(SDLK_HASH),
	KE(SDLK_DOLLAR),
	KE(SDLK_AMPERSAND),
	KE(SDLK_QUOTE),
	KE(SDLK_LEFTPAREN),
	KE(SDLK_RIGHTPAREN),
	KE(SDLK_ASTERISK),
	KE(SDLK_PLUS),
	KE(SDLK_COMMA),
	KE(SDLK_MINUS),
	KE(SDLK_PERIOD),
	KE(SDLK_SLASH),
	KE(SDLK_0),
	KE(SDLK_1),
	KE(SDLK_2),
	KE(SDLK_3),
	KE(SDLK_4),
	KE(SDLK_5),
	KE(SDLK_6),
	KE(SDLK_7),
	KE(SDLK_8),
	KE(SDLK_9),
	KE(SDLK_COLON),
	KE(SDLK_SEMICOLON),
	KE(SDLK_LESS),
	KE(SDLK_EQUALS),
	KE(SDLK_GREATER),
	KE(SDLK_QUESTION),
	KE(SDLK_AT),
	KE(SDLK_LEFTBRACKET),
	KE(SDLK_BACKSLASH),
	KE(SDLK_RIGHTBRACKET),
	KE(SDLK_CARET),
	KE(SDLK_UNDERSCORE),
	KE(SDLK_BACKQUOTE),
	KE(SDLK_a),
	KE(SDLK_b),
	KE(SDLK_c),
	KE(SDLK_d),
	KE(SDLK_e),
	KE(SDLK_f),
	KE(SDLK_g),
	KE(SDLK_h),
	KE(SDLK_i),
	KE(SDLK_j),
	KE(SDLK_k),
	KE(SDLK_l),
	KE(SDLK_m),
	KE(SDLK_n),
	KE(SDLK_o),
	KE(SDLK_p),
	KE(SDLK_q),
	KE(SDLK_r),
	KE(SDLK_s),
	KE(SDLK_t),
	KE(SDLK_u),
	KE(SDLK_v),
	KE(SDLK_w),
	KE(SDLK_x),
	KE(SDLK_y),
	KE(SDLK_z),
	KE(SDLK_DELETE),
	KE(SDLK_WORLD_0),
	KE(SDLK_WORLD_1),
	KE(SDLK_WORLD_2),
	KE(SDLK_WORLD_3),
	KE(SDLK_WORLD_4),
	KE(SDLK_WORLD_5),
	KE(SDLK_WORLD_6),
	KE(SDLK_WORLD_7),
	KE(SDLK_WORLD_8),
	KE(SDLK_WORLD_9),
	KE(SDLK_WORLD_10),
	KE(SDLK_WORLD_11),
	KE(SDLK_WORLD_12),
	KE(SDLK_WORLD_13),
	KE(SDLK_WORLD_14),
	KE(SDLK_WORLD_15),
	KE(SDLK_WORLD_16),
	KE(SDLK_WORLD_17),
	KE(SDLK_WORLD_18),
	KE(SDLK_WORLD_19),
	KE(SDLK_WORLD_20),
	KE(SDLK_WORLD_21),
	KE(SDLK_WORLD_22),
	KE(SDLK_WORLD_23),
	KE(SDLK_WORLD_24),
	KE(SDLK_WORLD_25),
	KE(SDLK_WORLD_26),
	KE(SDLK_WORLD_27),
	KE(SDLK_WORLD_28),
	KE(SDLK_WORLD_29),
	KE(SDLK_WORLD_30),
	KE(SDLK_WORLD_31),
	KE(SDLK_WORLD_32),
	KE(SDLK_WORLD_33),
	KE(SDLK_WORLD_34),
	KE(SDLK_WORLD_35),
	KE(SDLK_WORLD_36),
	KE(SDLK_WORLD_37),
	KE(SDLK_WORLD_38),
	KE(SDLK_WORLD_39),
	KE(SDLK_WORLD_40),
	KE(SDLK_WORLD_41),
	KE(SDLK_WORLD_42),
	KE(SDLK_WORLD_43),
	KE(SDLK_WORLD_44),
	KE(SDLK_WORLD_45),
	KE(SDLK_WORLD_46),
	KE(SDLK_WORLD_47),
	KE(SDLK_WORLD_48),
	KE(SDLK_WORLD_49),
	KE(SDLK_WORLD_50),
	KE(SDLK_WORLD_51),
	KE(SDLK_WORLD_52),
	KE(SDLK_WORLD_53),
	KE(SDLK_WORLD_54),
	KE(SDLK_WORLD_55),
	KE(SDLK_WORLD_56),
	KE(SDLK_WORLD_57),
	KE(SDLK_WORLD_58),
	KE(SDLK_WORLD_59),
	KE(SDLK_WORLD_60),
	KE(SDLK_WORLD_61),
	KE(SDLK_WORLD_62),
	KE(SDLK_WORLD_63),
	KE(SDLK_WORLD_64),
	KE(SDLK_WORLD_65),
	KE(SDLK_WORLD_66),
	KE(SDLK_WORLD_67),
	KE(SDLK_WORLD_68),
	KE(SDLK_WORLD_69),
	KE(SDLK_WORLD_70),
	KE(SDLK_WORLD_71),
	KE(SDLK_WORLD_72),
	KE(SDLK_WORLD_73),
	KE(SDLK_WORLD_74),
	KE(SDLK_WORLD_75),
	KE(SDLK_WORLD_76),
	KE(SDLK_WORLD_77),
	KE(SDLK_WORLD_78),
	KE(SDLK_WORLD_79),
	KE(SDLK_WORLD_80),
	KE(SDLK_WORLD_81),
	KE(SDLK_WORLD_82),
	KE(SDLK_WORLD_83),
	KE(SDLK_WORLD_84),
	KE(SDLK_WORLD_85),
	KE(SDLK_WORLD_86),
	KE(SDLK_WORLD_87),
	KE(SDLK_WORLD_88),
	KE(SDLK_WORLD_89),
	KE(SDLK_WORLD_90),
	KE(SDLK_WORLD_91),
	KE(SDLK_WORLD_92),
	KE(SDLK_WORLD_93),
	KE(SDLK_WORLD_94),
	KE(SDLK_WORLD_95),
	KE(SDLK_KP0),
	KE(SDLK_KP1),
	KE(SDLK_KP2),
	KE(SDLK_KP3),
	KE(SDLK_KP4),
	KE(SDLK_KP5),
	KE(SDLK_KP6),
	KE(SDLK_KP7),
	KE(SDLK_KP8),
	KE(SDLK_KP9),
	KE(SDLK_KP_PERIOD),
	KE(SDLK_KP_DIVIDE),
	KE(SDLK_KP_MULTIPLY),
	KE(SDLK_KP_MINUS),
	KE(SDLK_KP_PLUS),
	KE(SDLK_KP_ENTER),
	KE(SDLK_KP_EQUALS),
	KE(SDLK_UP),
	KE(SDLK_DOWN),
	KE(SDLK_RIGHT),
	KE(SDLK_LEFT),
	KE(SDLK_INSERT),
	KE(SDLK_HOME),
	KE(SDLK_END),
	KE(SDLK_PAGEUP),
	KE(SDLK_PAGEDOWN),
	KE(SDLK_F1),
	KE(SDLK_F2),
	KE(SDLK_F3),
	KE(SDLK_F4),
	KE(SDLK_F5),
	KE(SDLK_F6),
	KE(SDLK_F7),
	KE(SDLK_F8),
	KE(SDLK_F9),
	KE(SDLK_F10),
	KE(SDLK_F11),
	KE(SDLK_F12),
	KE(SDLK_F13),
	KE(SDLK_F14),
	KE(SDLK_F15),
	KE(SDLK_NUMLOCK),
	KE(SDLK_CAPSLOCK),
	KE(SDLK_SCROLLOCK),
	KE(SDLK_RSHIFT),
	KE(SDLK_LSHIFT),
	KE(SDLK_RCTRL),
	KE(SDLK_LCTRL),
	KE(SDLK_RALT),
	KE(SDLK_LALT),
	KE(SDLK_RMETA),
	KE(SDLK_LMETA),
	KE(SDLK_LSUPER),
	KE(SDLK_RSUPER),
	KE(SDLK_MODE),
	KE(SDLK_COMPOSE),
	KE(SDLK_HELP),
	KE(SDLK_PRINT),
	KE(SDLK_SYSREQ),
	KE(SDLK_BREAK),
	KE(SDLK_MENU),
	KE(SDLK_POWER),
	KE(SDLK_EURO),
	KE(SDLK_UNDO),
	KE(SDLK_LAST),
	KE(-1)
};

static key_lookup_table mame_lookup[] =
{
	KE(KEYCODE_A),
 	KE(KEYCODE_B),
 	KE(KEYCODE_C),
 	KE(KEYCODE_D),
 	KE(KEYCODE_E),
 	KE(KEYCODE_F),
	KE(KEYCODE_G),
 	KE(KEYCODE_H),
 	KE(KEYCODE_I),
 	KE(KEYCODE_J),
 	KE(KEYCODE_K),
 	KE(KEYCODE_L),
	KE(KEYCODE_M),
 	KE(KEYCODE_N),
 	KE(KEYCODE_O),
 	KE(KEYCODE_P),
 	KE(KEYCODE_Q),
 	KE(KEYCODE_R),
	KE(KEYCODE_S),
 	KE(KEYCODE_T),
 	KE(KEYCODE_U),
 	KE(KEYCODE_V),
 	KE(KEYCODE_W),
 	KE(KEYCODE_X),
	KE(KEYCODE_Y),
 	KE(KEYCODE_Z),
 	KE(KEYCODE_0),
 	KE(KEYCODE_1),
 	KE(KEYCODE_2),
 	KE(KEYCODE_3),
	KE(KEYCODE_4),
 	KE(KEYCODE_5),
 	KE(KEYCODE_6),
 	KE(KEYCODE_7),
 	KE(KEYCODE_8),
 	KE(KEYCODE_9),
	KE(KEYCODE_F1),
 	KE(KEYCODE_F2),
 	KE(KEYCODE_F3),
 	KE(KEYCODE_F4),
 	KE(KEYCODE_F5),
	KE(KEYCODE_F6),
 	KE(KEYCODE_F7),
 	KE(KEYCODE_F8),
 	KE(KEYCODE_F9),
 	KE(KEYCODE_F10),
	KE(KEYCODE_F11),
 	KE(KEYCODE_F12),
 	KE(KEYCODE_F13),
 	KE(KEYCODE_F14),
 	KE(KEYCODE_F15),
	KE(KEYCODE_ESC),
 	KE(KEYCODE_TILDE),
 	KE(KEYCODE_MINUS),
 	KE(KEYCODE_EQUALS),
 	KE(KEYCODE_BACKSPACE),
	KE(KEYCODE_TAB),
 	KE(KEYCODE_OPENBRACE),
 	KE(KEYCODE_CLOSEBRACE),
 	KE(KEYCODE_ENTER),
 	KE(KEYCODE_COLON),
	KE(KEYCODE_QUOTE),
 	KE(KEYCODE_BACKSLASH),
 	KE(KEYCODE_BACKSLASH2),
 	KE(KEYCODE_COMMA),
 	KE(KEYCODE_STOP),
	KE(KEYCODE_SLASH),
 	KE(KEYCODE_SPACE),
 	KE(KEYCODE_INSERT),
 	KE(KEYCODE_DEL),
	KE(KEYCODE_HOME),
 	KE(KEYCODE_END),
 	KE(KEYCODE_PGUP),
 	KE(KEYCODE_PGDN),
	KE(KEYCODE_LEFT),
	KE(KEYCODE_RIGHT),
 	KE(KEYCODE_UP),
 	KE(KEYCODE_DOWN),
	KE(KEYCODE_0_PAD),
 	KE(KEYCODE_1_PAD),
 	KE(KEYCODE_2_PAD),
 	KE(KEYCODE_3_PAD),
 	KE(KEYCODE_4_PAD),
	KE(KEYCODE_5_PAD),
 	KE(KEYCODE_6_PAD),
 	KE(KEYCODE_7_PAD),
 	KE(KEYCODE_8_PAD),
 	KE(KEYCODE_9_PAD),
	KE(KEYCODE_SLASH_PAD),
 	KE(KEYCODE_ASTERISK),
 	KE(KEYCODE_MINUS_PAD),
 	KE(KEYCODE_PLUS_PAD),
	KE(KEYCODE_DEL_PAD),
 	KE(KEYCODE_ENTER_PAD),
 	KE(KEYCODE_PRTSCR),
 	KE(KEYCODE_PAUSE),
	KE(KEYCODE_LSHIFT),
 	KE(KEYCODE_RSHIFT),
 	KE(KEYCODE_LCONTROL),
 	KE(KEYCODE_RCONTROL),
	KE(KEYCODE_LALT),
 	KE(KEYCODE_RALT),
 	KE(KEYCODE_SCRLOCK),
 	KE(KEYCODE_NUMLOCK),
 	KE(KEYCODE_CAPSLOCK),
	KE(KEYCODE_LWIN),
 	KE(KEYCODE_RWIN),
 	KE(KEYCODE_MENU),
 	KE(-1)
};

#ifdef MESS
extern int win_use_natural_keyboard;
static const INT32 mess_keytrans[][2] =
{
	{ SDLK_ESCAPE,	UCHAR_MAMEKEY(ESC) },
	{ SDLK_F1,		UCHAR_MAMEKEY(F1) },
	{ SDLK_F2,		UCHAR_MAMEKEY(F2) },
	{ SDLK_F3,		UCHAR_MAMEKEY(F3) },
	{ SDLK_F4,		UCHAR_MAMEKEY(F4) },
	{ SDLK_F5,		UCHAR_MAMEKEY(F5) },
	{ SDLK_F6,		UCHAR_MAMEKEY(F6) },
	{ SDLK_F7,		UCHAR_MAMEKEY(F7) },
	{ SDLK_F8,		UCHAR_MAMEKEY(F8) },
	{ SDLK_F9,		UCHAR_MAMEKEY(F9) },
	{ SDLK_F10,		UCHAR_MAMEKEY(F10) },
	{ SDLK_F11,		UCHAR_MAMEKEY(F11) },
	{ SDLK_F12,		UCHAR_MAMEKEY(F12) },
	{ SDLK_LCTRL,	        UCHAR_MAMEKEY(LCONTROL) },
	{ SDLK_RCTRL,	        UCHAR_MAMEKEY(RCONTROL) },
	{ SDLK_NUMLOCK,	        UCHAR_MAMEKEY(NUMLOCK) },
	{ SDLK_CAPSLOCK,	UCHAR_MAMEKEY(CAPSLOCK) },
	{ SDLK_SCROLLOCK,	UCHAR_MAMEKEY(SCRLOCK) },
	{ SDLK_KP0,	UCHAR_MAMEKEY(0_PAD) },
	{ SDLK_KP1,	UCHAR_MAMEKEY(1_PAD) },
	{ SDLK_KP2,	UCHAR_MAMEKEY(2_PAD) },
	{ SDLK_KP3,	UCHAR_MAMEKEY(3_PAD) },
	{ SDLK_KP4,	UCHAR_MAMEKEY(4_PAD) },
	{ SDLK_KP5,	UCHAR_MAMEKEY(5_PAD) },
	{ SDLK_KP6,	UCHAR_MAMEKEY(6_PAD) },
	{ SDLK_KP7,	UCHAR_MAMEKEY(7_PAD) },
	{ SDLK_KP8,	UCHAR_MAMEKEY(8_PAD) },
	{ SDLK_KP9,	UCHAR_MAMEKEY(9_PAD) },
	{ SDLK_KP_PERIOD,	UCHAR_MAMEKEY(DEL_PAD) },
	{ SDLK_KP_PLUS,		UCHAR_MAMEKEY(PLUS_PAD) },
	{ SDLK_KP_MINUS,	UCHAR_MAMEKEY(MINUS_PAD) },
	{ SDLK_INSERT,	UCHAR_MAMEKEY(INSERT) },
	{ SDLK_DELETE,	UCHAR_MAMEKEY(DEL) },
	{ SDLK_HOME,		UCHAR_MAMEKEY(HOME) },
	{ SDLK_END,		UCHAR_MAMEKEY(END) },
	{ SDLK_PAGEUP,		UCHAR_MAMEKEY(PGUP) },
	{ SDLK_PAGEDOWN, 	UCHAR_MAMEKEY(PGDN) },
	{ SDLK_UP,		UCHAR_MAMEKEY(UP) },
	{ SDLK_DOWN,		UCHAR_MAMEKEY(DOWN) },
	{ SDLK_LEFT,		UCHAR_MAMEKEY(LEFT) },
	{ SDLK_RIGHT,		UCHAR_MAMEKEY(RIGHT) },
	{ SDLK_PAUSE,		UCHAR_MAMEKEY(PAUSE) },
};
#endif

static struct {
	int		logical;
	int		ismapped;
	char	*name;
} joy_map[MAX_JOYMAP];

static int joy_logical[MAX_JOYSTICKS];

static int lookup_key_code(const key_lookup_table *kt, char *kn)
{
	int i=0;
	if (!kn)
		return -1;
	while (kt[i].code>=0)
	{
		if (!strcmp(kn, kt[i].name))
			return kt[i].code;
		i++;
	}
	return -1;
}

static int win_has_menu(void)
{
#ifdef MESS
       return mess_ui_active() || ui_is_menu_active();
#else
       return ui_is_menu_active();
#endif
}

//============================================================
//  autoselect_analog_devices
//============================================================

static void autoselect_analog_devices(const input_port_entry *inp, int type1, int type2, int type3, int anatype, const char *ananame)
{
	// loop over input ports
	for ( ; inp->type != IPT_END; inp++)
	
		// if this port type is in use, apply the autoselect criteria
		if ((type1 != 0 && inp->type == type1) ||
			(type2 != 0 && inp->type == type2) ||
			(type3 != 0 && inp->type == type3))
		{
			// autoenable mouse devices
			if (analog_type[anatype] == SELECT_TYPE_MOUSE && !use_mouse)
			{
				use_mouse = 1;
				mame_printf_verbose("Autoenabling mice due to presence of a %s\n", ananame);
			}
				
			// autoenable joystick devices
			if (analog_type[anatype] == SELECT_TYPE_JOYSTICK && !use_joystick)
			{
				use_joystick = 1;
				mame_printf_verbose("Autoenabling joysticks due to presence of a %s\n", ananame);
			}
				
			// all done
			break;
		}
}

//============================================================
//  sdl_pause_input
//============================================================

static void sdl_pause_input(running_machine *machine, int paused)
{
	input_paused = paused;
}

//============================================================
//	wininput_exit
//============================================================

static void sdlinput_exit(running_machine *machine)
{
	int stick;
	
	for (stick=0; stick < joystick_count; stick++)
		SDL_JoystickClose(joystick_device[stick]);

#ifdef SDLMAME_WIN32
	osd_lock_free(input_lock);
	event_buf_count = 0;
#endif
}

static int joy_map_leastfree(void)
{
	int i,j,found;
	for (i=0;i<MAX_JOYSTICKS;i++)
	{
		found = 0;
		for (j=0;j<MAX_JOYMAP;j++)
			if (joy_map[j].logical == i)
				found = 1;
		if (!found)
			return i;
	}
	return -1;
}

static char *remove_spaces(const char *s)
{
	char *r, *p;
	static const char *def_name[] = { "Unknown" };

	while (*s && *s == ' ')
		s++;

	if (strlen(s) == 0)
	{
		r = auto_malloc(strlen((char *)def_name)+1);
		strcpy(r, (char *)def_name);
		return r;
	}

	r = auto_malloc(strlen(s));
	p = r;
	while (*s)
	{
		if (*s != ' ')
			*p++ = *s++;
		else
		{
			while (*s && *s == ' ')
				s++;
			if (*s)
				*p++ = ' ';
		}
	}
	*p = 0;
	return r;
}

//============================================================
//  wininput_init
//============================================================

int sdlinput_init(running_machine *machine)
{
	const input_port_entry *inp;
	int physical_stick, axis, button, mouse;
	char tempname[512];
	SDL_Joystick *joy;

	input_paused = 0;
	add_pause_callback(machine, sdl_pause_input);

	// decode the options
	extract_input_config();

	// make sure we start at 0
	total_codes = 0;
	
	init_keycodes();
	init_joymap();
	memset(keyboard_state, 0, sizeof(keyboard_state));

	// enable devices based on autoselect
	if (Machine != NULL && Machine->gamedrv != NULL)
	{
		begin_resource_tracking();
		inp = input_port_allocate(Machine->gamedrv->ipt, NULL);
		autoselect_analog_devices(inp, IPT_PADDLE,     IPT_PADDLE_V,    0,             ANALOG_TYPE_PADDLE,    "paddle");
		autoselect_analog_devices(inp, IPT_AD_STICK_X, IPT_AD_STICK_Y,  IPT_AD_STICK_Z,ANALOG_TYPE_ADSTICK,   "analog joystick");
		autoselect_analog_devices(inp, IPT_LIGHTGUN_X, IPT_LIGHTGUN_Y,  0,             ANALOG_TYPE_LIGHTGUN,  "lightgun");
		autoselect_analog_devices(inp, IPT_PEDAL,      IPT_PEDAL2,      IPT_PEDAL3,    ANALOG_TYPE_PEDAL,     "pedal");
		autoselect_analog_devices(inp, IPT_DIAL,       IPT_DIAL_V,      0,             ANALOG_TYPE_DIAL,      "dial");
		autoselect_analog_devices(inp, IPT_TRACKBALL_X,IPT_TRACKBALL_Y, 0,             ANALOG_TYPE_TRACKBALL, "trackball");
#ifdef MESS
		autoselect_analog_devices(inp, IPT_MOUSE_X,    IPT_MOUSE_Y,    0,             ANALOG_TYPE_MOUSE,    "mouse");
#endif // MESS
		end_resource_tracking();
	}

	if (use_mouse)
	{
		mouse = 0;
		sprintf(tempname, "Mouse %d X", mouse + 1);
		add_joylist_entry(tempname, JOYCODE(mouse, CODETYPE_MOUSEAXIS, 0), CODE_OTHER_ANALOG_RELATIVE);
		// add negative & positive digital values
		sprintf(tempname, "Mouse %d X -", mouse + 1);
		add_joylist_entry(tempname, JOYCODE(mouse, CODETYPE_MOUSE_NEG, 0), CODE_OTHER_DIGITAL);
		sprintf(tempname, "Mouse %d X +", mouse + 1);
		add_joylist_entry(tempname, JOYCODE(mouse, CODETYPE_MOUSE_POS, 0), CODE_OTHER_DIGITAL);

		sprintf(tempname, "Mouse %d Y", mouse + 1);
		add_joylist_entry(tempname, JOYCODE(mouse, CODETYPE_MOUSEAXIS, 1), CODE_OTHER_ANALOG_RELATIVE);
		// add negative & positive digital values
		sprintf(tempname, "Mouse %d Y -", mouse + 1);
		add_joylist_entry(tempname, JOYCODE(mouse, CODETYPE_MOUSE_NEG, 1), CODE_OTHER_DIGITAL);
		sprintf(tempname, "Mouse %d Y +", mouse + 1);
		add_joylist_entry(tempname, JOYCODE(mouse, CODETYPE_MOUSE_POS, 1), CODE_OTHER_DIGITAL);

		for (button = 0; button < 4; button++)
		{
			sprintf(tempname, "Mouse %d B%d", mouse + 1, button + 1);
			add_joylist_entry(tempname, JOYCODE(mouse, CODETYPE_MOUSEBUTTON, button), CODE_OTHER_DIGITAL);
		}
	}

	joystick_count = 0;
	if (use_joystick)
	{
		int stick, i, first_free;
		mame_printf_verbose("Joystick: Start initialization\n");
		for (physical_stick = 0; physical_stick < SDL_NumJoysticks(); physical_stick++)
		{
			char *joy_name = remove_spaces(SDL_JoystickName(physical_stick));
			
			joystick_count++;

			stick = -1;
			first_free = 0;
			for (i=0;i<MAX_JOYSTICKS;i++)
			{
				if (!first_free && !joy_map[i].name[0])
					first_free = i;
				if (!joy_map[i].ismapped && !strcmp(joy_name,joy_map[i].name))
				{
					stick = joy_map[i].logical;
					joy_map[i].ismapped = 1;
				}
			}
			if (stick == -1)
			{
				stick = joy_map_leastfree();
				joy_map[first_free].logical = stick;
				joy_map[first_free].name	= joy_name;
				joy_map[first_free].ismapped = 1;
			}
			
			joy_logical[physical_stick] = stick;
			
			// loop over all axes
			joy = SDL_JoystickOpen(physical_stick);
			joystick_device[physical_stick] = joy;

			mame_printf_verbose("Joystick: %s\n", joy_name);
			mame_printf_verbose("Joystick:   ...  %d axes, %d buttons %d hats\n", SDL_JoystickNumAxes(joy), SDL_JoystickNumButtons(joy), SDL_JoystickNumHats(joy));
			mame_printf_verbose("Joystick:   ...  Physical id %d mapped to logical id %d\n", physical_stick, stick);

			for (axis = 0; axis < SDL_JoystickNumAxes(joy); axis++)
			{
				// add analog axes
				if (!joystick_digital[stick][axis])
				{
					sprintf(tempname, "J%d A%d %s", stick + 1, axis, joy_name);
					add_joylist_entry(tempname, JOYCODE(stick, CODETYPE_JOYAXIS, axis), CODE_OTHER_ANALOG_ABSOLUTE);
					// add negative & positive analog axis
					sprintf(tempname, "J%d A%d + %s", stick + 1, axis, joy_name);
					add_joylist_entry(tempname, JOYCODE(stick, CODETYPE_JOYAXIS_POS, axis), CODE_OTHER_ANALOG_ABSOLUTE);
					sprintf(tempname, "J%d A%d - %s", stick + 1, axis, joy_name);
					add_joylist_entry(tempname, JOYCODE(stick, CODETYPE_JOYAXIS_NEG, axis), CODE_OTHER_ANALOG_ABSOLUTE);
				} 
		
				// add negative & positive digital values
				sprintf(tempname, "J%d axis %d -", stick + 1, axis);
				add_joylist_entry(tempname, JOYCODE(stick, CODETYPE_AXIS_NEG, axis), CODE_OTHER_DIGITAL);
				sprintf(tempname, "J%d axis %d +", stick + 1, axis);
				add_joylist_entry(tempname, JOYCODE(stick, CODETYPE_AXIS_POS, axis), CODE_OTHER_DIGITAL);
			}

			// loop over all buttons
			for (button = 0; button < SDL_JoystickNumButtons(joy); button++)
			{
				sprintf(tempname, "J%d button %d", stick + 1, button);
				add_joylist_entry(tempname, JOYCODE(stick, CODETYPE_BUTTON, button), CODE_OTHER_DIGITAL);
			}
		}
		mame_printf_verbose("Joystick: End initialization\n");
	}
	
	#ifdef SDLMAME_WIN32
	input_lock = osd_lock_alloc();
	#endif
	add_exit_callback(machine, sdlinput_exit);
	
	return 0;
}


//============================================================
//	sdl_process_events
//============================================================

#ifdef SDLMAME_WIN32
void sdlinput_process_events_buf(void)
{
	SDL_Event event;

	osd_lock_acquire(input_lock);
	while(SDL_PollEvent(&event)) 
	{
		if (event_buf_count < MAX_BUF_EVENTS)
			event_buf[event_buf_count++] = event;
		else
			mame_printf_warning("Event Buffer Overflow!\n");	
	}
	osd_lock_release(input_lock);
}
#endif

void sdlinput_process_events(void)
{
	SDL_Event event;
	int i;
	#ifdef MESS
	int translated;
	#endif
#ifdef SDLMAME_WIN32
	SDL_Event			loc_event_buf[MAX_BUF_EVENTS];
	int					loc_event_buf_count;
	int bufp;
#endif

	for (i=0;i<MAX_JOYSTICKS;i++)
	{
	        mouse_state[i].lX = 0;
	        mouse_state[i].lY = 0;
	}
	if (keyboard_state[SDLK_CAPSLOCK]) 
	{
		/* auto key-up caps-lock */
		keyboard_state[SDLK_CAPSLOCK] = 0;
		updatekeyboard();
	}

#ifdef SDLMAME_WIN32
	osd_lock_acquire(input_lock);
	memcpy(loc_event_buf, event_buf, sizeof(event_buf));
	loc_event_buf_count = event_buf_count;
	event_buf_count = 0;
	osd_lock_release(input_lock);
	bufp = 0;
	while (bufp < loc_event_buf_count) {
		event = loc_event_buf[bufp++];
#else
	while(SDL_PollEvent(&event)) {
#endif
		if (event.type == SDL_KEYUP && 
		    event.key.keysym.sym == SDLK_CAPSLOCK)
		{
			/* more caps-lock hack */
			event.type = SDL_KEYDOWN;
		}
		switch(event.type) {
		case SDL_QUIT:
			mame_schedule_exit(Machine);
			break;
		case SDL_KEYDOWN:
			#ifdef MESS
			if (win_use_natural_keyboard)
			{
				translated = 0;
				for (i = 0; i < sizeof(mess_keytrans) / sizeof(mess_keytrans[0]); i++)
				{
					if (event.key.keysym.sym == mess_keytrans[i][0])
					{
						translated = 1;
						inputx_postc(mess_keytrans[i][1]);
					}
				}

				if (!translated)
				{
					inputx_postc(event.key.keysym.unicode);
				}
			}
			#endif
			keyboard_state[event.key.keysym.sym] = 1;
			updatekeyboard();
			break;
		case SDL_KEYUP:
			keyboard_state[event.key.keysym.sym] = 0;
			updatekeyboard();
			break;
		case SDL_JOYAXISMOTION:
 			joystick_state[joy_logical[event.jaxis.which]].axes[event.jaxis.axis] = (event.jaxis.value * 2);
			break;
		case SDL_JOYBUTTONDOWN:
		case SDL_JOYBUTTONUP:
			joystick_state[joy_logical[event.jbutton.which]].buttons[event.jbutton.button] = event.jbutton.state == SDL_PRESSED;
			break;
		case SDL_MOUSEBUTTONDOWN:
			mouse_state[0].buttons[event.button.button-1] = 1;
			break;
		case SDL_MOUSEBUTTONUP:
			mouse_state[0].buttons[event.button.button-1] = 0;
			break;
		case SDL_MOUSEMOTION:
			mouse_state[0].lX = event.motion.xrel;
			mouse_state[0].lY = event.motion.yrel;
			break;
		case SDL_VIDEORESIZE:
			sdlwindow_resize(event.resize.w, event.resize.h);
			break;
		}
	}
}

//============================================================
//  parse_analog_select
//============================================================

static void parse_analog_select(int type, const char *option)
{
	const char *stemp = options_get_string(mame_options(), option);

	if (strcmp(stemp, "keyboard") == 0)
		analog_type[type] = SELECT_TYPE_KEYBOARD;
	else if (strcmp(stemp, "mouse") == 0)
		analog_type[type] = SELECT_TYPE_MOUSE;
	else if (strcmp(stemp, "joystick") == 0)
		analog_type[type] = SELECT_TYPE_JOYSTICK;
	else
	{
		mame_printf_warning("Invalid %s value %s; reverting to keyboard\n", option, stemp);
		analog_type[type] = SELECT_TYPE_KEYBOARD;
	}
}


//============================================================
//  parse_digital
//============================================================

static void parse_digital(const char *option)
{
	const char *soriginal = options_get_string(mame_options(), option);
	const char *stemp = soriginal;

	if (strcmp(stemp, "none") == 0)
		memset(joystick_digital, 0, sizeof(joystick_digital));
	else if (strcmp(stemp, "all") == 0)
		memset(joystick_digital, 1, sizeof(joystick_digital));
	else
	{
		/* scan the string */
		while (1)
		{
			int joynum = 0;
			int axisnum = 0;

			/* stop if we hit the end */
			if (stemp[0] == 0)
				break;

			/* we require the next bits to be j<N> */
			if (tolower(stemp[0]) != 'j' || sscanf(&stemp[1], "%d", &joynum) != 1)
				goto usage;
			stemp++;
			while (stemp[0] != 0 && isdigit(stemp[0]))
				stemp++;

			/* if we are followed by a comma or an end, mark all the axes digital */
			if (stemp[0] == 0 || stemp[0] == ',')
			{
				if (joynum != 0 && joynum - 1 < MAX_JOYSTICKS)
					memset(&joystick_digital[joynum - 1], 1, sizeof(joystick_digital[joynum - 1]));
				if (stemp[0] == 0)
					break;
				stemp++;
				continue;
			}

			/* loop over axes */
			while (1)
			{
				/* stop if we hit the end */
				if (stemp[0] == 0)
					break;

				/* if we hit a comma, skip it and break out */
				if (stemp[0] == ',')
				{
					stemp++;
					break;
				}

				/* we require the next bits to be a<N> */
				if (tolower(stemp[0]) != 'a' || sscanf(&stemp[1], "%d", &axisnum) != 1)
					goto usage;
				stemp++;
				while (stemp[0] != 0 && isdigit(stemp[0]))
					stemp++;

				/* set that axis to digital */
				if (joynum != 0 && joynum - 1 < MAX_JOYSTICKS && axisnum < MAX_AXES)
					joystick_digital[joynum - 1][axisnum] = 1;
			}
		}
	}
	return;

usage:
	mame_printf_warning("Invalid %s value %s; reverting to all -- valid values are:\n", option, soriginal);
	mame_printf_warning("         none -- no axes on any joysticks are digital\n");
	mame_printf_warning( "         all -- all axes on all joysticks are digital\n");
	mame_printf_warning( "         j<N> -- all axes on joystick <N> are digital\n");
	mame_printf_warning( "         j<N>a<M> -- axis <M> on joystick <N> is digital\n");
	mame_printf_warning( "    Multiple axes can be specified for one joystick:\n");
	mame_printf_warning( "         j1a5a6 -- axes 5 and 6 on joystick 1 are digital\n");
	mame_printf_warning( "    Multiple joysticks can be specified separated by commas:\n");
	mame_printf_warning( "         j1,j2a2 -- all joystick 1 axes and axis 2 on joystick 2 are digital\n");
}

//============================================================
//  extract_input_config
//============================================================

static void extract_input_config(void)
{
	// extract boolean options
	use_mouse = options_get_bool(mame_options(), SDLOPTION_MOUSE);
	use_joystick = options_get_bool(mame_options(), SDLOPTION_JOYSTICK);
	steadykey = options_get_bool(mame_options(), SDLOPTION_STEADYKEY);
	a2d_deadzone = options_get_float(mame_options(), SDLOPTION_A2D_DEADZONE);
	parse_analog_select(ANALOG_TYPE_PADDLE, "paddle_device");
	parse_analog_select(ANALOG_TYPE_ADSTICK, "adstick_device");
	parse_analog_select(ANALOG_TYPE_PEDAL, "pedal_device");
	parse_analog_select(ANALOG_TYPE_DIAL, "dial_device");
	parse_analog_select(ANALOG_TYPE_TRACKBALL, "trackball_device");
	parse_analog_select(ANALOG_TYPE_LIGHTGUN, "lightgun_device");
	parse_analog_select(ANALOG_TYPE_POSITIONAL, "positional_device");
#ifdef MESS
	parse_analog_select(ANALOG_TYPE_MOUSE, "mouse_device");
#endif
	parse_digital("digital");
}
 
static void win_clear_keyboard(void)
{
	memset(keyboard_state, 0, sizeof(keyboard_state));
}

//============================================================
//	is_mouse_captured
//============================================================

int sdl_is_mouse_captured(void)
{
	return (!input_paused && mouse_active && use_mouse && !win_has_menu());
}



//============================================================
//  updatekeyboard
//============================================================

// since the keyboard controller is slow, it is not capable of reporting multiple
// key presses fast enough. We have to delay them in order not to lose special moves
// tied to simultaneous button presses.

static void updatekeyboard(void)
{
	int i, changed = 0;

	// see if any keys have changed state
	for (i = 0; i < MAX_KEYS; i++)
		if (keyboard_state[i] != oldkey[i])
		{
			changed = 1;

			// keypress was missed, turn it on for one frame
			if (keyboard_state[i] == 0 && currkey[i] == 0)
				currkey[i] = -1;
		}

	// if keyboard state is stable, copy it over
	if (!changed)
		memcpy(currkey, &keyboard_state[0], sizeof(currkey));

	// remember the previous state
	memcpy(oldkey, &keyboard_state[0], sizeof(oldkey));
}



//============================================================
//  is_key_pressed
//============================================================

static int is_key_pressed(os_code keycode)
{
	int sdlk = SDLCODE(keycode);

	// return the current keystate
	if (steadykey)
		return currkey[sdlk];
	else
		return keyboard_state[sdlk];
}


//============================================================
//  init_joymap
//============================================================

static void init_joymap(void)
{
	int stick;

	for (stick=0; stick < MAX_JOYMAP; stick++)
	{
		joy_map[stick].name = (char *)"";
		joy_map[stick].logical = -1;
		joy_map[stick].ismapped = 0;
	}
		
	if (options_get_bool(mame_options(), SDLOPTION_JOYMAP))
	{
		FILE *joymap_file;
		int line = 1;
		char *joymap_filename;
	
		joymap_filename = (char *)options_get_string(mame_options(), SDLOPTION_JOYMAP_FILE);
		mame_printf_verbose("Joymap: Start reading joymap_file %s\n", joymap_filename);

		joymap_file = fopen(joymap_filename, "r");

		if (joymap_file == NULL)
		{
			mame_printf_warning( "Joymap: Unable to open joymap %s - using default mapping\n", joymap_filename);
		}
		else
		{
			int i, cnt, logical;
			char buf[256];
			char name[65];
			
			cnt=0;
			while (!feof(joymap_file) && fgets(buf, 255, joymap_file))
			{
				if (*buf && buf[0] && buf[0] != '#')
				{
					buf[255]=0;
					i=strlen(buf);
					if (i && buf[i-1] == '\n')
						buf[i-1] = 0;
					memset(name, 0, 65);
					logical = -1;
					sscanf(buf, "%x %64c\n", &logical, name);
					if ((logical >=0 ) && (logical < MAX_JOYSTICKS))
					{
						joy_map[cnt].logical = logical;
						joy_map[cnt].name = remove_spaces(name);
						mame_printf_verbose("Joymap: Logical id %d: %s\n", logical, joy_map[cnt].name);
						cnt++;
					}
					else
						mame_printf_warning("Joymap: Error reading keymap: Line %d: %s\n", line, buf);
				}
				line++;
			}
			fclose(joymap_file);
			mame_printf_verbose("Joymap: Processed %d lines\n", line);
		}
	}
}


//============================================================
//  init_keycodes
//============================================================

static void init_keycodes(void)
{
	int key = 0;
	int (*key_trans_table)[4] = NULL;
	char **ui_name = NULL;

	if (options_get_bool(mame_options(), SDLOPTION_KEYMAP))
	{
		char *keymap_filename;
		FILE *keymap_file;
		int line = 1;

		keymap_filename = (char *)options_get_string(mame_options(), SDLOPTION_KEYMAP_FILE);
		mame_printf_verbose("Keymap: Start reading keymap_file %s\n", keymap_filename);

		keymap_file = fopen(keymap_filename, "r");

		if (keymap_file == NULL)
		{
			mame_printf_warning( "Keymap: Unable to open keymap %s, using default\n", keymap_filename);
			key_trans_table = (int (*)[4])def_key_trans_table;
		}
		else
		{
			int index,i, mk, sk, vk, ak;
			char buf[256];
			char mks[21];
			char sks[21];
			char kns[21];
			
			i=0;
			while (def_key_trans_table[i][MAME_KEY]>=0 )
				i++;
			key_trans_table = malloc_or_die( sizeof(int) * 4 * (i+1));
			memcpy(key_trans_table, def_key_trans_table, sizeof(int) * 4 * (i+1));
			ui_name = malloc_or_die( sizeof(char *) * (i+1));
			memset(ui_name, 0, sizeof(char *) * (i+1));
			while (!feof(keymap_file))
			{
				fgets(buf, 255, keymap_file);
				if (*buf && buf[0] && buf[0] != '#')
				{
					buf[255]=0;
					i=strlen(buf);
					if (i && buf[i-1] == '\n')
						buf[i-1] = 0;
					mks[0]=0;
					sks[0]=0;
					memset(kns, 0, 21);
					sscanf(buf, "%20s %20s %x %x %20c\n",
							mks, sks, &vk, &ak, kns);
					index=-1;
					i=0;
					mk = lookup_key_code(mame_lookup, mks);
					sk = lookup_key_code(sdl_lookup, sks);
					if ( sk >= 0 && mk >=0) 
					{
						while (key_trans_table[i][MAME_KEY]>=0 )
						{
							if (key_trans_table[i][MAME_KEY]==mk)
						  	{
								index=i;
							}	
							i++;
						}
						if (index>=0)
						{
							key_trans_table[index][SDL_KEY] = sk;
							key_trans_table[index][VIRTUAL_KEY] = vk;
							key_trans_table[index][ASCII_KEY] = ak;
							ui_name[index] = auto_malloc(strlen(kns)+1);
							strcpy(ui_name[index], kns);
							mame_printf_verbose("Keymap: Mapped <%s> to <%s> with ui-text <%s>\n", sks, mks, kns);
						}
					}
					else
						mame_printf_warning("Keymap: Error on line %d: %s\n", line, buf);
				}
				line++;
			}
			fclose(keymap_file);
			mame_printf_verbose("Keymap: Processed %d lines\n", line);
		}
	}
	else
	{
		key_trans_table = (int (*)[4])def_key_trans_table;
	}

	// iterate over all possible keys
	while (key_trans_table[key][0] >= 0) 
	{
		// copy the name

		char *namecopy;

		input_code standardcode;
		os_code code;

		// compute the code, which encodes DirectInput, virtual, and ASCII codes
		code = KEYCODE(key_trans_table[key][SDL_KEY], key_trans_table[key][VIRTUAL_KEY], key_trans_table[key][ASCII_KEY]);
		standardcode = key_trans_table[key][MAME_KEY];

		// fill in the key description
		if (ui_name && ui_name[key] && *ui_name[key])
		{
			namecopy = ui_name[key];
		}
		else 
		{
			namecopy = auto_malloc(strlen(key_name_table[key])+1);
			strcpy(namecopy, key_name_table[key]);
		}
		codelist[total_codes].name = namecopy;
		codelist[total_codes].oscode = code;
		codelist[total_codes].inputcode = standardcode;
		total_codes++;

		key++;
	} 
}



//============================================================
//  add_joylist_entry
//============================================================

static void add_joylist_entry(const char *name, os_code code, input_code standardcode)
{
	// copy the name
	char *namecopy = auto_malloc(strlen(name) + 1);
	if (namecopy)
	{
		int entry;

		// find the table entry, if there is one
		for (entry = 0; entry < ELEMENTS(joy_trans_table); entry++)
			if (joy_trans_table[entry][0] == code)
				break;

		// fill in the joy description
		codelist[total_codes].name = strcpy(namecopy, name);
		codelist[total_codes].oscode = code;
		if (entry < ELEMENTS(joy_trans_table))
			standardcode = joy_trans_table[entry][1];
		codelist[total_codes].inputcode = standardcode;
		total_codes++;
	}
}



//============================================================
//  get_joycode_value
//============================================================

static INT32 get_joycode_value(os_code joycode)
{
	int joyindex = JOYINDEX(joycode);
	int codetype = CODETYPE(joycode);
	int joynum = JOYNUM(joycode);
	INT32 retv = 0;

	// switch off the type
	switch (codetype)
	{
		case CODETYPE_MOUSEBUTTON:
			return mouse_state[joynum].buttons[joyindex];
		case CODETYPE_BUTTON:
			return joystick_state[joynum].buttons[joyindex];

		case CODETYPE_AXIS_POS:
		{
			int val = joystick_state[joynum].axes[joyindex];
			int top = 32767;
			int middle = 0;
			return (val > middle + ((top - middle) * a2d_deadzone));
		}

		case CODETYPE_AXIS_NEG:
		{
			int val = joystick_state[joynum].axes[joyindex];
			int bottom = -32768;
			int middle = 0;

			return (val < middle - ((middle - bottom) * a2d_deadzone));
		}

#if 0
		// anywhere from 0-45 (315) deg to 0+45 (45) deg
		case CODETYPE_POV_UP:
			pov = joystick_state[joynum].rgdwPOV[joyindex];
			return ((pov & 0xffff) != 0xffff && (pov >= 31500 || pov <= 4500));

		// anywhere from 90-45 (45) deg to 90+45 (135) deg
		case CODETYPE_POV_RIGHT:
			pov = joystick_state[joynum].rgdwPOV[joyindex];
			return ((pov & 0xffff) != 0xffff && (pov >= 4500 && pov <= 13500));

		// anywhere from 180-45 (135) deg to 180+45 (225) deg
		case CODETYPE_POV_DOWN:
			pov = joystick_state[joynum].rgdwPOV[joyindex];
			return ((pov & 0xffff) != 0xffff && (pov >= 13500 && pov <= 22500));

		// anywhere from 270-45 (225) deg to 270+45 (315) deg
		case CODETYPE_POV_LEFT:
			pov = joystick_state[joynum].rgdwPOV[joyindex];
			return ((pov & 0xffff) != 0xffff && (pov >= 22500 && pov <= 31500));
#endif

		// analog joystick axis
		case CODETYPE_JOYAXIS:
		case CODETYPE_JOYAXIS_NEG:
		case CODETYPE_JOYAXIS_POS:
			if (!use_joystick)
				return 0;
			else
			{
				int val = ((int *)&joystick_state[joynum].axes)[joyindex];

				if (!use_joystick)
					return 0;
				if (val < ANALOG_VALUE_MIN) val = ANALOG_VALUE_MIN;
				if (val > ANALOG_VALUE_MAX) val = ANALOG_VALUE_MAX;
				if (codetype == CODETYPE_JOYAXIS)
					return val;

				if (codetype ==  CODETYPE_JOYAXIS_NEG)
					val = (val < 0) ? 0 - val : 0;
				else
					val = (val > 0) ? val : 0;

				return val * 2 + ANALOG_VALUE_MIN;
			}

		// analog mouse axis
		case CODETYPE_MOUSEAXIS:
		// digital mouse direction
		case CODETYPE_MOUSE_NEG:
		case CODETYPE_MOUSE_POS:
			// if the mouse isn't yet active, make it so
			if (!mouse_active && use_mouse && !win_has_menu())
			{
				mouse_active = 1;
			}

			// return the latest mouse info
			if (joyindex == 0)
			{
				retv = mouse_state[joynum].lX * 512;
			}
			if (joyindex == 1)
			{
				retv = mouse_state[joynum].lY * 512;
			}

			if (codetype == CODETYPE_MOUSEAXIS)
			{
				return retv;
			}
			else
			{
				if (codetype == CODETYPE_MOUSE_POS)
					return retv > 0;
				else
					return retv < 0;
			}

			// unreachable
			// return 0;

#if 0		
		// analog gun axis
		case CODETYPE_GUNAXIS:
			// return the latest gun info
			if (joynum >= MAX_LIGHTGUNS)
				return 0;
			if (joyindex >= 2)
				return 0;
			return gun_axis[joynum][joyindex];
#endif
	}

	// keep the compiler happy
	return 0;
}



//============================================================
//  osd_get_code_value
//============================================================

INT32 osd_get_code_value(os_code code)
{
	if (IS_KEYBOARD_CODE(code))
		return is_key_pressed(code);
	else
		return get_joycode_value(code);
}



//============================================================
//  osd_get_code_list
//============================================================

const os_code_info *osd_get_code_list(void)
{
	return codelist;
}

//============================================================
//  osd_customize_inputport_list
//============================================================

void osd_customize_inputport_list(input_port_default_entry *defaults)
{
	static input_seq no_alt_tab_seq = SEQ_DEF_5(KEYCODE_TAB, CODE_NOT, KEYCODE_LALT, CODE_NOT, KEYCODE_RALT);
	input_port_default_entry *idef = defaults;

	// loop over all the defaults
	while (idef->type != IPT_END)
	{
		// map in some OSD-specific keys
		switch (idef->type)
		{
			#ifdef MESS
			// configurable UI mode switch
			case IPT_UI_TOGGLE_UI:
				seq_set_1(&idef->defaultseq, lookup_key_code(mame_lookup, (char *)options_get_string(mame_options(), SDLOPTION_UIMODEKEY)));
				break;
			#endif
			// alt-enter for fullscreen
			case IPT_OSD_1:
				idef->token = "TOGGLE_FULLSCREEN";
				idef->name = "Toggle Fullscreen";
				seq_set_2(&idef->defaultseq, KEYCODE_ENTER, KEYCODE_LALT);
				break;
			// disable UI_SELECT when LALT is down, this stops selecting
			// things in the menu when toggling fullscreen with LALT+ENTER
			case IPT_UI_SELECT:
				seq_set_3(&idef->defaultseq, KEYCODE_ENTER, CODE_NOT, KEYCODE_LALT);
				break;

			// page down for fastforward (must be OSD_3 as per src/emu/ui.c)
			case IPT_OSD_3:
				idef->token = "FAST_FORWARD";
				idef->name = "Fast Forward";
				seq_set_1(&idef->defaultseq, KEYCODE_PGDN);
				break;
			
			// OSD hotkeys use LCTRL and start at F3, they start at
			// F3 because F1-F2 are hardcoded into many drivers to
			// various dipswitches, and pressing them together with
			// LCTRL will still press/toggle these dipswitches.

			// LCTRL-F3 to toggle fullstretch
			case IPT_OSD_2:
				idef->token = "TOGGLE_FULLSTRETCH";
				idef->name = "Toggle Uneven stretch";
				seq_set_2(&idef->defaultseq, KEYCODE_F3, KEYCODE_LCONTROL);
				break;
			// add a Not lcrtl condition to the reset key
			case IPT_UI_SOFT_RESET:
				seq_set_5(&idef->defaultseq, KEYCODE_F3, CODE_NOT, KEYCODE_LCONTROL, CODE_NOT, KEYCODE_LSHIFT);
				break;
			
			// LCTRL-F4 to toggle keep aspect
			case IPT_OSD_4:
				idef->token = "TOGGLE_KEEP_ASPECT";
				idef->name = "Toggle Keepaspect";
				seq_set_2(&idef->defaultseq, KEYCODE_F4, KEYCODE_LCONTROL);
				break;
			// add a Not lcrtl condition to the show gfx key
			case IPT_UI_SHOW_GFX:
				seq_set_3(&idef->defaultseq, KEYCODE_F4, CODE_NOT, KEYCODE_LCONTROL);
				break;
			
			// LCTRL-F5 to toggle OpenGL filtering
			case IPT_OSD_5:
				idef->token = "TOGGLE_FILTER";
				idef->name = "Toggle Filter";
				seq_set_2(&idef->defaultseq, KEYCODE_F5, KEYCODE_LCONTROL);
				break;
			// add a Not lcrtl condition to the toggle debug key
			case IPT_UI_TOGGLE_DEBUG:
				seq_set_3(&idef->defaultseq, KEYCODE_F5, CODE_NOT, KEYCODE_LCONTROL);
				break;
			
			// LCTRL-F6 to decrease OpenGL prescaling
			case IPT_OSD_6:
				idef->token = "DECREASE_PRESCALE";
				idef->name = "Decrease Prescaling";
				seq_set_2(&idef->defaultseq, KEYCODE_F6, KEYCODE_LCONTROL);
				break;
			// add a Not lcrtl condition to the toggle cheat key
			case IPT_UI_TOGGLE_CHEAT:
				seq_set_3(&idef->defaultseq, KEYCODE_F6, CODE_NOT, KEYCODE_LCONTROL);
				break;
			
			// LCTRL-F7 to increase OpenGL prescaling
			case IPT_OSD_7:
				idef->token = "INCREASE_PRESCALE";
				idef->name = "Increase Prescaling";
				seq_set_2(&idef->defaultseq, KEYCODE_F7, KEYCODE_LCONTROL);
				break;
			// add a Not lcrtl condition to the load state key
			case IPT_UI_LOAD_STATE:
				seq_set_5(&idef->defaultseq, KEYCODE_F7, CODE_NOT, KEYCODE_LCONTROL, CODE_NOT, KEYCODE_LSHIFT);
				break;
			
			// LCTRL-F8 to decrease prescaling effect #
			case IPT_OSD_8:
				if (getenv("SDLMAME_UNSUPPORTED")) {
					idef->token = "DECREASE_EFFECT";
					idef->name = "Decrease Effect";
					seq_set_2(&idef->defaultseq, KEYCODE_F8, KEYCODE_LCONTROL);
				}
				break;
			// add a Not lcrtl condition to frameskip decrease
			case IPT_UI_FRAMESKIP_DEC:
				if (getenv("SDLMAME_UNSUPPORTED"))
					seq_set_3(&idef->defaultseq, KEYCODE_F8, CODE_NOT, KEYCODE_LCONTROL);
				break;
			
			// LCTRL-F9 to increase prescaling effect #
			case IPT_OSD_9:
				if (getenv("SDLMAME_UNSUPPORTED")) {
					idef->token = "INCREASE_EFFECT";
					idef->name = "Increase Effect";
					seq_set_2(&idef->defaultseq, KEYCODE_F9, KEYCODE_LCONTROL);
				}
				break;
			// add a Not lcrtl condition to frameskip increase
			case IPT_UI_FRAMESKIP_INC:
				if (getenv("SDLMAME_UNSUPPORTED"))
					seq_set_3(&idef->defaultseq, KEYCODE_F9, CODE_NOT, KEYCODE_LCONTROL);
				break;
			
			// LCTRL-F10 to toggle the renderer (software vs opengl)
			case IPT_OSD_10:
				idef->token = "TOGGLE_RENDERER";
				idef->name = "Toggle OpenGL/software rendering";
				seq_set_2(&idef->defaultseq, KEYCODE_F10, KEYCODE_LCONTROL);
				break;
			// add a Not lcrtl condition to the throttle key
			case IPT_UI_THROTTLE:
				seq_set_3(&idef->defaultseq, KEYCODE_F10, CODE_NOT, KEYCODE_LCONTROL);
				break;
			
			// disable the config menu if the ALT key is down
			// (allows ALT-TAB to switch between windows apps)
			case IPT_UI_CONFIGURE:
				seq_copy(&idef->defaultseq, &no_alt_tab_seq);
				break;
		}

		// find the next one
		idef++;
	}
}
